[
  {
    "objectID": "server.html",
    "href": "server.html",
    "title": "NCEAS’ Server",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nSummarize the primary steps for getting set up on a server\nConnect your GitHub self with your server self\nExplain at least one way of uploading data to a server",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "server.html#module-learning-objectives",
    "href": "server.html#module-learning-objectives",
    "title": "NCEAS’ Server",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nSummarize the primary steps for getting set up on a server\nConnect your GitHub self with your server self\nExplain at least one way of uploading data to a server",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "server.html#overview",
    "href": "server.html#overview",
    "title": "NCEAS’ Server",
    "section": "Overview",
    "text": "Overview\nWorking on NCEAS’ Server is similar to working on an entirely separate computer from the laptop or desktop computer on which you typically work. This means that you need to go through the steps of connecting GitHub to your “RStudio” again for the instance of RStudio accessed through Aurora. GitHub’s Personal Access Token is referred to as “token” hereafter for simplicity. Note that our server also runs other analytical tools such as JupyterHub for python users.\nOften the reason to engage with the server is to increase the scale of your analyses far beyond what your personal computer can handle. There are other advantages such as:\n\nStorage Capacity – More disk space & faster storage\nComputing Power – More CPUs & RAM (384GB!!)\nSecurity – Nightly backups and data are distributed across multiple drives\nCollaboration – Shared data & consistent software versions accessible to everyone on your team",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "server.html#getting-started-on-the-server",
    "href": "server.html#getting-started-on-the-server",
    "title": "NCEAS’ Server",
    "section": "Getting Started on the Server",
    "text": "Getting Started on the Server\n\nNecessary Software\nThe only software that you will need on your personal computer to get set up on NCEAS’ server is RStudio!\nYou likely have worked in the “Console” tab of RStudio (where run lines and outputs appear; see below) but RStudio has another tab to the right of the “Console” called “Terminal” which offers RStudio users access to the command line (a.k.a. the shell). If you are a veteran command line user you may prefer to use the standalone Terminal app on MacOS or PuTTY on Windows but for the sake of keeping your tool kit streamlined, we’ll walk through getting set up on NCEAS’ server using only RStudio’s Terminal tab.\n\n\n\nThe Terminal does not accept R syntax (and the Console doesn’t accept Terminal syntax) so you may notice that some of the code we’ll walk you through below is formatted differently than you would write an R script.\n\n\n\n\n\nGet Invited!\nIn order to access the server (and follow the instructions below) we’ll need to create an account on the server for you. Please email someone on our team or scicomp@nceas.ucsb.edu so that we can contact NCEAS’ IT team and get an invite email sent to you.\nIn that email, please include the name and email addresses of all of your team members who want to access the server. After that information has been received, NCEAS’ IT team will create accounts for all of those people and will send you an invitation email to set up your account on the server.\nAn example of what that email may look like is included below but there are two key pieces of information:\n\nYour username\nYour temporary password (covered by a red bar in the screenshot).\n\nIf you have not received that email, check your Spam folder for emails from Thomas Hetmank (hetmank@nceas.ucsb.edu) or Nick Outin (outin@nceas.ucsb.edu). If you have not received the email and it is not in your Spam, reach out to our team and we will work to get an invite sent to you.\n\n\n\n\n\nSigning into the Server\nIn the following instructions, all words that look like this should be typed into the Terminal tab and run by pressing return or enter. Note that typing these commands into an R script or R Markdown will not work because it will attempt to run in the Console. All words that look [like this] (i.e., bracketed) should also be typed into the Terminal tab but the specific text should be replaced in a user-specific way that is clarified in the nearby text.\n\nIn the Terminal pane of RStudio, you will “ssh” into the server by running the following code: ssh [your username]@aurora.nceas.ucsb.edu. It is @aurora because the name of the server is Aurora.\nIf this is the first time you’ve accessed the server you will need to enter yes to accept the server’s SSH key.\nYou will then be prompted to enter your [temporary password] (see the above email example). Note that the cursor will not advance as you type but it is registering your entries! There will be no indication that you are typing (such as: “•••••••••”) This throws off many users so hopefully the above note helps set your mind at ease.\nYou will then be prompted to change your “expired” password. We consider your temporary password to be expired as soon as you use it because sharing passwords via email is not secure and this “expiration” lets you set the password to something that only you know at the outset of your time in the server. Note again that the cursor will not advance as you type but it is working! To update your password, enter your [temporary password], then [your strong new password] and finally re-type [your strong new password] to confirm it. Note that your new password should not be “your strong new password” :)\nYou are ready to go! Run exit to log out of the server in the Terminal tab.\nNow that you have set a new password, use your favorite web browser (e.g., Firefox, Chrome, etc.) to access Aurora and click “Login to RStudio Server”\nIn the resulting page, you can sign in with the same username and password you just signed in on the Terminal tab with.\nYou should now be in something that looks very much like RStudio but is housed in a tab on your browser! We will work together from here on out so once you have reached this point, let our team know and we can gather the group before continuing.\n\nIf the above steps have not resulted in successfully accessing Aurora, consult NCEAS’ instructions on first login and/or SSH-specific instructions for Mac vs. Windows and/or email us!\n\n\nConnecting GitHub and the Server\nYour server “self” is essentially a different computer that you access via a browser (or command line in some cases). Because of this, you will need to tell GitHub that your server self is allowed to access your GitHub self’s content. To do this you’ll need to authenticate via personal access token or SSH key pair. Revisit our authentication instructions in the “Workshop Preparation” section of the workshop home page for details.\n\n\n\n\n\n\nTipServer + PAT Note\n\n\n\nIf you choose token-based authentication you’ll also need to tell the server to store your token for some amount of time otherwise the server will “forget” it between sessions.\nIn the Terminal pane of the server’s RStudio session run the following code:\n\ngit config --global credential.helper 'cache --timeout=10000000'\n\nThis tells your server self to remember your token for 10 million minutes (roughly 20 years).\n\n\n\n\nOptional Other Steps\nYou may want to configure additional settings, such as:\n\nThe default branch name (for new repositories)\n\n\nusethis::git_default_branch_configure(name = \"main\")",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "server.html#working-on-the-server",
    "href": "server.html#working-on-the-server",
    "title": "NCEAS’ Server",
    "section": "Working on the Server",
    "text": "Working on the Server\nOnce you’re properly set up, working on the server should be completely seamless! Instead of opening RStudio on your computer you’ll open a browser and work on the server from there but otherwise the feeling and process of version control should be identical. Eventually you may even want to make commits on your computer, push them to GitHub (after pulling!), then pull those same commits down to your server self and continue working there.\nYou’ll find working on the server to be dramatically faster for computationally-intense operations so we hope this guide has been helpful in getting you prepared to take advantage of that benefit!",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "server.html#uploading-data-to-the-server",
    "href": "server.html#uploading-data-to-the-server",
    "title": "NCEAS’ Server",
    "section": "Uploading Data to the Server",
    "text": "Uploading Data to the Server\n\nVia RStudio\nIf you are uploading a single file, it may be most convenient to use RStudio’s data upload capabilities. In the “Files” pane (default is top right but it may differ on your computer), you can click the button that is a white rectangle with a yellow circle with an upward facing arrow inside of it. In the below image the relevant button is in a red square.\n\n\n\nClicking that button allows you to choose (1) where you want the uploaded file to go and (2) which file you want to upload.\n\n\n\nYou can also download data via the RStudio interface. To download a file, check the box next to it in the “Files” pane.\n\n\n\nOnce the box is checked, click the gear icon then click the “Export…” option (about halfway down). In the image below this option is surrounded by a red square\n\n\n\nIn the resulting box you can choose to rename the file before downloading to your local computer. After renaming the file (or keeping its original name), click the “Download” button and the download should begin after a moment.\n\n\n\nThese methods are effective for one or a few files being up/downloaded to the same directory but can quickly become cumbersome if you want to handle many files or a few files to several different folders.\n\n\nVia sFTP Software\nIf you want to upload or download many files we recommend using sFTP software (secure File Transfer Protocol). We use Cyberduck internally, though there are alternatives like WinSCP. Both programs are free to use and more than capable of uploading and download many files to/from the server quickly and easily.\nOnce you have installed one of these programs, you can sign in to the server from the sFTP program using your server username and password and can then upload or download files from your personal computer in the same way as you would move files among folders within your personal computer.\n\nCyberduck Set Up Tutorial\nHere we briefly demonstrate how to set up a connection between Cyberduck and NCEAS’ Server. Note that you must have already installed Cyberduck to follow these steps.\n\nIn the Cyberduck window, click the “Open Connection” button with an icon of a globe with a plus sign. In the below image the button has a red square around it.\n\n\n\n\n\nIn the resulting window, input the following information:\n\n“Server” – “aurora.nceas.ucsb.edu”\n“Username” – whatever your username on the server is\n“Password” – your password to the server\n“Port” – change it to “22” (it will start as “21”)\n\n\n\n\n\n\nAlso, click the dropdown menu at the top that says “FTP (File Transfer Protocol) and select”SFTP (SSH File Transfer Protocol)” from the set of available options.\n\n\n\n\n\nOnce you’ve input the above information, click the “Connect” button and you should have access to the server! You can now click around the different folders you have access to and upload or download from there.\n\n\nTo download: click the files/folders that you want and they should begin downloading to your personal computer\nTo upload: drag and drop the files where you want them\n\n\n\n\nVia the Command Line\nIf you are more comfortable with a CLI (Command Line Interface) you can also use that method of uploading/downloading. The command line includes the Terminal pane in RStudio, Terminal app for Macs, PuTTY, and gitBash among others. CLI can be a great tool to leverage filenames or types to filter specific files you would like to upload / download. Text in code chunks below are command line commands and any bracketed text [like this] should be replaced by some user-specific information before running.\nThis portion of the tutorial is focused on using the command line to interact with the server. That said, if you’re interested in the command line more generally or for other purposes, please reach out to our team!\n\nCLI Option A: scp\nThe scp command can be used to upload a file or folder from your computer to the server.\n1A. Navigate to the folder on your computer containing the file(s) you want to upload\n\ncd [folder]\n\n\nNote that if the folder name has spaces you’ll need to “escape” the space by using a backslash (\\)\n\n\ncd [folder\\ name]\n\n2A. Now you can upload that file to the server!\n\nscp [file_name] [user]@aurora.nceas.ucsb.edu:/[path/to/destination_folder/]\n\nIf instead you’d like to upload all of the files in a folder, do the following:\n1B. Navigate to the folder containing the folder on your computer you want to upload (using cd)\n\ncd [folder]\n\n2B. Use scp with the recursive option (-r) to upload all of the files in that folder\n\nscp -r [folder] [user]@aurora.nceas.ucsb.edu:/[path/to/destination_folder/]\n\n\nNote that this uploads all of the files in the folder not the folder itself so you may want to create a new folder on the server to upload your local folder’s contents into.\n\nFinally, note that you can also download files from the server to your local machine by simply switching the order of the machines:\n\nscp [user]@aurora.nceas.ucsb.edu:/[path/to/server_folder/file_name] [local_folder] \n\n\n\nCLI Option B: sftp\nThe get command can be used to download a file.\n\nConnect to the server\n\n\nsftp [user]@aurora.nceas.ucsb.edu:/home/shares\n\nYour prompt at the shell should now have switched to sftp&gt; and although it is the same window you are now looking at the files on the server! Try it by typing the ls command at the prompts. This will list all the files and folders within the shares folder on Aurora.\n\nEnter your group’s folder in the shares folder\n\n\ncd [your_group_folder]\n\n\nIf needed, continue using cd to get to the subfolder you want to access. Remember to “escape” any spaces in the folder name with backslashes!\n\n\ncd [subfolder]\n\nNote that most of the bash command will work, so you can use ls to list files and pwd to check your current path.\n\nWhen you are in the folder containing the file(s) you want, download the file you want\n\n\nget [file_name_server]\n\n\nYou can also upload a local file to the server by using the put sFTP command\n\n\nput [file_name_local]\n\n\nWhen you are done downloading, close the connection to the server\n\n\nexit",
    "crumbs": [
      "Other Topics",
      "NCEAS' Server"
    ]
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "GitHub Projects",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine a project in the context of GitHub\nIdentify the three available project view options\nExplain how issues can get added to projects",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#module-learning-objectives",
    "href": "projects.html#module-learning-objectives",
    "title": "GitHub Projects",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine a project in the context of GitHub\nIdentify the three available project view options\nExplain how issues can get added to projects",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#what-is-a-project",
    "href": "projects.html#what-is-a-project",
    "title": "GitHub Projects",
    "section": "What is a Project?",
    "text": "What is a Project?\nProjects are GitHub’s primary strategic project management tool. While issues can be very useful for particular tasks, they are less valuable for making larger-scale plans and tracking evolving priorities. A project acts as an umbrella that includes many issues and tracks their inter-relationships and where they fit in a bigger-picture view of a project.",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#project-ownership",
    "href": "projects.html#project-ownership",
    "title": "GitHub Projects",
    "section": "Project Ownership",
    "text": "Project Ownership\nProjects can only be created for a particular User or an Organization. In either case, any number of users can be allowed access to the project. The list of all projects owned by an Organization/User can be accessed via the “projects” tab. Note that this tab’s name is consistent for Users and Organizations; Organizations just have more tabs to support the expanded set of tools available to them. Note that in the screenshot below we are in an organization (“lter”) not a specific repository.\n\n\n\nOnce a project has been created, it can be “linked” to any number of repositories owned by that entity. This can be done from the “Projects” tab of each repository to which linking is desired. Note in the top left of the screenshot below that we are in a repository (“lter-sparc-soil-p”).",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#using-projects",
    "href": "projects.html#using-projects",
    "title": "GitHub Projects",
    "section": "Using Projects",
    "text": "Using Projects\nWithin the team that created this workshop, we use GitHub Issues to track and document each task that we do for a working group. We then use a GitHub project to let each team member track all of their Issues and ensure that we rotate through which group we are helping. This guarantees equitable effort for each working group and allows each team member to balance all of the tasks on their docket at any given moment.\nSee below for a screenshot of what such a project looks like for one team member.\n\n\n\nWhen using a project you can add or remove the columns (the above example has four columns) and individual issue “cards” can be clicked and dragged among columns. You can also automate a column so that Issues that meet certain criteria are automatically moved to a particular column (e.g., Issues added to this project are automatically moved to the “Done” column).",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#project-views",
    "href": "projects.html#project-views",
    "title": "GitHub Projects",
    "section": "Project “Views”",
    "text": "Project “Views”\nGitHub supports three different view options within projects. You can have as many views as you’d like, including duplicates of the same category of view. Views can be created or toggled between in the top left of the screen, just beneath the project title.\n\n\n\nAccepted project view options are “Board”, “Table”, and “Roadmap.” We will highlight the major features of each view below but note that in all included screen captures the actual issues in the project are the same! Picking a view option is essentially only a user interface change, not a fundamental change to how tasks are managed by or added to a given project (more on that later!).\n\nBoard View\nThe first view option (and in our opinion the best for working groups) is the “board” option. In this view, issues are tracked in vertical columns and can be dragged among columns at will. Columns are often used to denote issue status such that columns further to the right are closer to finished. Column names, colors, and description text can all be edited to fit your team’s needs.\n\n\n\n\n\nTable View\nThe second view option is the ‘table’ option. This view stacks all current tasks vertically and automatically sorts them by the task status (equivalent to the columns in the board view). If your team typically uses an MS Excel / Google Sheet file to track your ongoing work, this project view would represent the closest user interface match.\n\n\n\n\n\nRoadmap View\nThe final view option is the ‘roadmap’. This view allows for tracking of issues through time more explicitly than the other two view options. You can choose the temporal specificity that makes most sense for your work (allowed options include daily, monthly, quarterly, and yearly breakdowns). Tasks then show up as a long bar in their row extending from whatever their start date is to the user-defined end date. Note that for this view to work you will need to add specific start/end dates to every issue.",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#integrating-issues",
    "href": "projects.html#integrating-issues",
    "title": "GitHub Projects",
    "section": "Integrating Issues",
    "text": "Integrating Issues\nOnce you’ve created the project(s) you want, issues can be added to them as desired! You can either add issues at the Issue creation stage or from the project itself after the Issue has been created.\n\nAdding from an Issue\nWhen you first create an issue you can add it to one or more projects by clicking the gear icon in the sidebar of options on the right side of the screen.\n\n\n\nUpon clicking that icon, a small window will pop up and will allow you to choose any project (A) you’ve interacted with recently, (B) that is linked to this particular repository, and/or (C) that is owned by the Organization/User that owns the repository. If there are many projects that meet these criteria there is also a handy search bar that lets you search through for a specific project by name.\n\n\n\n\n\nAdding from a Project\nIf you’d prefer, you can add existing issues to a project from the project’s home screen. Once in the project, click the “Add item” button at the bottom of the screen and begin typing the name of the issue. Clicking an issue’s name will then automatically add it to the project and will allow you to “triage” it (i.e., add the issue to the column indicating its current status).",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "projects.html#maximizing-project-utility",
    "href": "projects.html#maximizing-project-utility",
    "title": "GitHub Projects",
    "section": "Maximizing Project Utility",
    "text": "Maximizing Project Utility\nIt may go without saying, but projects are at their most valuable as project management tools when you make effective use of GitHub Issues. Specifically, the three Issue capabilities that will benefit your adoption of projects are as follows:\n\nGiving Issues clear and short titles\n“Assigning” Issues to particular users\nUsing labels to group Issues into useful categories\n\nIf your team is considering these three points, then adopting GitHub projects will further empower your ability to track your internal tasks over time. Feel free to consult our page on Issues for more information!",
    "crumbs": [
      "Project Management",
      "GitHub Projects"
    ]
  },
  {
    "objectID": "prep-steps/install_r.html",
    "href": "prep-steps/install_r.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "Now you should install R on your computer. If you already have R, check that you have at least version 4.0.0 by looking at the “Console” of your IDE of choice.\nIf your version starts with a “3”, please update R to make sure all packages behave as expected."
  },
  {
    "objectID": "prep-steps/install_git.html",
    "href": "prep-steps/install_git.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "You can now install Git! Git is the software that actually does the behind-the-scenes version control operations we’ll cover in this workshop. Installing Git differs slightly depending on your operating system so check out the tabs below for the right option for you. These instructions are modified from Jennifer Bryan’s excellent “Happy Git and GitHub for the useR” ebook.\n\n Mac Windows Linux\n\n\nRun the following  command line code.\nxcode-select --install\nFor more detailed instructions, see here.\n\n\nInstall Git for Windows (a.k.a. “Git Bash”). When asked about “Adjusting your PATH environment”, select “Git from the command line and also from 3rd-party software”.\nFor more detailed instructions, see here.\n\n\nInstall Git via your distro’s package manager (in the  Terminal).\nIf you use Ubuntu or Debian Linux that  code is as follows:\nsudo apt-get install git\nIf instead you use Fedora or RedHat Linux the  code is instead:\nsudo yum install git\nFor more detailed instructions, see here."
  },
  {
    "objectID": "prep-steps/connect_git-github_rstudio.html",
    "href": "prep-steps/connect_git-github_rstudio.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "The last step to take before you’re all set for the workshop is to get these components talking to one another! You set a password for your GitHub which is used for logging in to GitHub but to actually put your code changes from your computer up to GitHub you’ll need to authenticate yourself. There are two paths for authentication:\n\nPersonal Access Token (PAT)\nSecure Shell (SSH)\n\nWhat’s the difference? Essentially, authenticating via token makes many things “just work” while authenticating via SSH will work for some things but in other contexts you would also need to do token-based authentication. For a more complete discussion of the benefits and drawbacks of each, see Dr. Bryan’s “HTTPS versus SSH” page.\nFollow the steps of your chosen authentication method in the tabs below.\n\nTokenSSH Key\n\n\nAll of the code chunks for authenticating with a token are  R code that should be run in the “Console” pane of RStudio. You may also create a script and run the code from there if you so desire but you’ll likely only need this code once so the script’s value would be short-lived.\n\n\n“Classic” versus “Fine-Grained” Tokens\n\nIf you follow the steps outlined below, you will make a “classic” token. This is the recommended method! GitHub also supports “fine-grained” tokens but they are a little more error-prone for the ways working groups tend to use GitHub.\nFor all the nitty gritty detail, check out GitHub’s documentation on tokens but essentially fine-grained tokens only work for repositories that you personally own. Because LTER working groups tend to work primarily in a repository owned by the LTER Network Office GitHub Organization, this means that a fine-grained token won’t let you edit your group’s repository.\nSo, make sure that you make a “classic” token! Feel free to reach out to the SciComp team if questions arise on this point!\n\n\n# Install the `usethis` and `gitcreds` packages\ninstall.packages(c(\"usethis\", \"gitcreds\"))\n\n# Add your GitHub username and email\nusethis::use_git_config(user.name = \"Your GitHub Username\",\n                        user.email = \"Your GitHub Email\")\n\n# Create a token (Note this will open a GitHub browser tab)\n## See steps 6-10 in GitHub's PAT tutorial (link below)\n1usethis::create_github_token()\n\n\n1\n\nLeave parentheses empty\n\n\n\n\nCopy your token at the end of the above step. Once you leave the page where your token is displayed you’ll never get to see it again! So if you close that page without copying it you’ll need to make a new one in order to continue.\nOnce you’ve copied your token, run the code below to save your credentials in RStudio.\n\n# Now, give your token to RStudio\n## After you run this line follow the prompts in the \"Console\" tab of RStudio\n2gitcreds::gitcreds_set()\n\n\n2\n\nLeave parentheses empty here as well!\n\n\n\n\nThis line of code will prompt you to paste your token in the “Console” tab. After you do so (and hit “Enter”), your token will be safely stored in RStudio!\n\nFurther Information\nYou may also find GitHub’s PAT tutorial (this is the link referenced in the first token-authentication code chunk!) or the Happy Git with R PAT tutorial helpful.\n\n\n\nAll of the code chunks for authenticating with SSH are  command line code that should be agnostic to your programming language.\nFirst, we need to check whether you already have SSH keys created on your computer. If you get a message saying that nothing exists or the path doesn’t exist, you do not (yet) have SSH keys.\n\nls -al ~/.ssh/\n\nIf you do need to create an SSH key pair you can do so via the command line. When you create a key pair you’ll need to include a descriptive comment to help ‘future you’ if you ever have multiple key pairs in your life. We recommend “lter” plus your GitHub username to keep things simple.\n\nssh-keygen -t ed25519 -C \"lter-github\"\n\n\n\n\n\n\n\nTipOlder Computer?\n\n\n\nIf you get a warning/error because your system is too old to support the Ed25519 algorithm (that’s the variant recommended by GitHub) you can instead use:\n\nssh-keygen -t rsa -b 4096 -C \"lter-github\"\n\n\n\nAccept the prompt to save the key in the default location by hitting Enter. You will be prompted to enter a passphrase that will be required to access your SSH key later on. This step is technically optional but is considered a best practice. If SSH keys are totally new to you, we recommend skipping the passphrase step.\nOnce you’ve generated the key pair, follow GitHub’s instructions on adding that key pair to your computer’s ssh-agent (roughly equivalent to a password manager but just for SSH key pairs).\nFinally, you need to share the public key with your GitHub self. Once again we’ll refer you to the phenomenal materials generated by Dr. Bryan on this topic.\n\nFurther Information\nYou may also find GitHub’s SSH documentation or the Happy Git with R SSH tutorial helpful."
  },
  {
    "objectID": "prep-steps/check_git-install_rstudio.html",
    "href": "prep-steps/check_git-install_rstudio.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "Regardless of your operating system, once you’ve installed Git, check that worked with the following  command line code. All operating systems should be able to run this code.\nwhich git\nRStudio should also be able to detect Git so let’s check from that side too. In RStudio click through the following menus: “Tools”  “Global Options”  “Git / SVN” (cardboard box icon in left sidebar). If you see a file path under “Git executable” then you are good to go!\nIf Git was not detected, this may be caused by having your RStudio session open while you installed Git for the first time. In that case, please close and restart RStudio before checking again."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "GitHub as a Portfolio",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nExplain the benefits of using GitHub as a portfolio\nIdentify ways to strengthen your profile’s presence on GitHub\nCreate a “special README” on your profile\nAdd informative READMEs to your repositories",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#module-learning-objectives",
    "href": "portfolio.html#module-learning-objectives",
    "title": "GitHub as a Portfolio",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nExplain the benefits of using GitHub as a portfolio\nIdentify ways to strengthen your profile’s presence on GitHub\nCreate a “special README” on your profile\nAdd informative READMEs to your repositories",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#why-use-github-as-a-portfolio",
    "href": "portfolio.html#why-use-github-as-a-portfolio",
    "title": "GitHub as a Portfolio",
    "section": "Why Use GitHub as a Portfolio?",
    "text": "Why Use GitHub as a Portfolio?\nGitHub is useful for tracking changes and hosting code which makes it a great place to showcase those same products! A fully fleshed-out GitHub profile will clearly capture who you are as a programmer/scientist, what you do, and allow people to get a neat overview of your work. A strong GitHub presence can help you stand out from a pool of many applicants for graduate school programs or other jobs; particularly when a proven track record of tech-savvy and knowledge of collaborative tools are listed as requirements. Having a detailed portfolio is a nice way to personally keep track of all the work and achievements you’ve accomplished as well! You can utilize GitHub’s existing functionalities to curate your own portfolio.",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#strengthen-your-presence-on-github",
    "href": "portfolio.html#strengthen-your-presence-on-github",
    "title": "GitHub as a Portfolio",
    "section": "Strengthen your presence on GitHub",
    "text": "Strengthen your presence on GitHub\n\nFlesh out your profile\nFilling out your profile details is an easy way to get started on your portfolio! To edit your profile, click on your icon in the top left corner and go to “Your profile”.\n\n\n\nThen select “Edit profile” on the right hand panel.\n\n\n\nThere, you will have options to edit your icon, name, biography, pronouns, workplace, location, website, and social media accounts. If you have links to other websites that contain your work, it’s a good idea to cross-reference them here so people can find you elsewhere.\n\n\n\nAlternatively, you can also edit your profile by clicking on your icon in the top left corner to go to “Settings”, then “Public profile”.\n\n\nPin repositories\nAdditionally, you can choose to pin up to 6 public repositories to show off to anyone who visits your profile. These pinned repos will be at the top of your profile page, greatly increasing their visibility to visitors.\nTo choose which repositories to pin, navigate to the “Your profile” tab again and click “Customize your pins”. Once you’ve pinned the repositories you particularly want to highlight you can reorder your pinned repos by dragging the 6 dots at the top right corner.\n\n\n\nWhen you’re picking out your top repositories we recommend including repositories that:\n\nYou’re excited about (passion is always worth highlighting!)\nShowcase a breadth of skills\nDemonstrate significant expertise in a narrow range of skills\nYou’re proud of / were significant to your career",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#special-readme",
    "href": "portfolio.html#special-readme",
    "title": "GitHub as a Portfolio",
    "section": "Special README",
    "text": "Special README\nA fun secret feature of GitHub is that you can have a “special README” displayed at the top of your profile! This is an easy way to present your work and interests to the rest of the GitHub community and anyone who visits your profile.\nTo get started, from your profile landing page, click on the ➕ button and select “New repository”.\n\n\n\nName your new repo the same name as your username. A notification should pop up indicating that you’re creating a special repo.\n\n\n\nFeel free to write an optional description. Set the repo visibility to public and make sure to check the box to initialize the repo with a README file. Click on the “Create repository” button once you’re done!\n\n\n\nThis is what the special repo will look like. Notice the notification on the right hand side informing you that the README.md file will appear on your profile. Click on the “Edit README” button to get started. Note that you could clone the special repo and edit from whatever code/text editor you prefer but given that the only editing you’ll do is to a markdown file that seems excessive to us.\n\n\n\nGitHub will have already populated README.md with a template that you can use as a starting point. Edit this Markdown file to your own liking. Here is a handy guide on formatting your text if you are not familiar with Markdown syntax.\nSome nice sections to include in your README.md are an “About me” section that gives a background on your work and interests, a contributions/achievements section, and a section on any other communities you’re involved in.\n\n\n\nYou can add emojis, images and GIFs so have fun editing your special README.",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#informative-readmes",
    "href": "portfolio.html#informative-readmes",
    "title": "GitHub as a Portfolio",
    "section": "Informative READMEs",
    "text": "Informative READMEs\nOn a related note, an informative README in each repository is crucial to orienting your audience to the files in and purpose of each repository. It’s good practice to add an informative README to every repository so visitors know its purpose and what it contains. A well-written README will be useful to both coders and non-coders alike. Check out the Scientific Computing team’s guide to writing informative READMEs here!",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "portfolio.html#how-to-stand-out",
    "href": "portfolio.html#how-to-stand-out",
    "title": "GitHub as a Portfolio",
    "section": "How to Stand Out",
    "text": "How to Stand Out\nIf you act on the suggestions we’ve outlined above you will already be well on the way to fully leveraging GitHub as a professional portfolio. That said, there are always means of making yourself and your work stand out even more! Below is a non-exhaustive list of some ideas for continuing to improve your portfolio.\n\nCreate a Personal Website\nPersonal websites are a cool way to visually convey everything that goes into a portfolio–your background, work experiences, interests, accomplishments, projects, contact information, etc. With a website, you can be more creative and flexible in how you want to present yourself to others. Plus, non-GitHub users may be more inclined to navigate someone’s personal website rather than their GitHub profile. A further benefit of creating a personal website is that you will learn (and demonstrate!) a suite of additional skills that contribute to your portfolio in and of themselves.\nAlthough the topic of creating your own personal website is outside the scope of this workshop, there are tons of resources on how to get started. If you’re interested, check out the SciComp team’s workshop on building a website with Quarto. Also feel free to check out Sam Csik’s tutorials on how to create and customize your website using Quarto.\nSince this will be a personal website deployed through GitHub Pages, remember to name your Quarto project and GitHub repo: &lt;YOUR-GITHUB-USERNAME&gt;.github.io, replacing &lt;YOUR-GITHUB-USERNAME&gt; with your actual username. You’re only allowed one user website with the github.io suffix. Follow the instructions in the linked tutorials to deploy the website via GitHub when you’re done! If all goes well, your website will be live at: https://&lt;YOUR-GITHUB-USERNAME&gt;.github.io/\nIf you’re looking for some inspiration, check out Angel’s (angelchen7.github.io) and Nick’s websites (njlyon0.github.io)!\n\n\nTeam up with Peers\nWithin any career path some of the best people to get professional feedback from are your peers! Your colleagues have applied to the same types of positions that you have and often have crucial insight that can help you learn from both the successes and the pitfalls that they have encountered. In addition, they can a well-trained critical eye that can help you improve your portfolio in ways you may never have imagined by yourself.\nOnce you have a draft portfolio, share it with your peers, advisers, and mentors for feedback. Write down their suggestions and act on all of the ones that seem reasonable to you. If you’d like, repeat this process of iterative revision for as long as you feel that it is needed! It may also make sense to gather other peers without GitHub portfolios into a journal club-style group and meet regularly to develop and critique one another’s materials.",
    "crumbs": [
      "Other Topics",
      "GitHub as a Portfolio"
    ]
  },
  {
    "objectID": "milestones.html",
    "href": "milestones.html",
    "title": "GitHub Milestones",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine what is a milestone in the context of GitHub\nExplain how GitHub milestones can be useful\nCreate a new GitHub milestone in an existing repository",
    "crumbs": [
      "Project Management",
      "GitHub Milestones"
    ]
  },
  {
    "objectID": "milestones.html#module-learning-objectives",
    "href": "milestones.html#module-learning-objectives",
    "title": "GitHub Milestones",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine what is a milestone in the context of GitHub\nExplain how GitHub milestones can be useful\nCreate a new GitHub milestone in an existing repository",
    "crumbs": [
      "Project Management",
      "GitHub Milestones"
    ]
  },
  {
    "objectID": "milestones.html#what-is-a-milestone",
    "href": "milestones.html#what-is-a-milestone",
    "title": "GitHub Milestones",
    "section": "What is a Milestone?",
    "text": "What is a Milestone?\nIf you like documenting your tasks and progress over time with GitHub issues, but the scope of your work doesn’t require you to rely on GitHub projects, then GitHub milestones may be perfect for you!\nGitHub milestones track issues and pull requests in a repository so you can see what tasks still need to be completed in order to achieve a particular goal. This is particularly helpful if you are doing a lot of work in a single repository and know what new features/objectives you want to implement there.\nOn the other hand, if your work consists of working across multiple repositories, then opening a GitHub project may be more appropriate.",
    "crumbs": [
      "Project Management",
      "GitHub Milestones"
    ]
  },
  {
    "objectID": "milestones.html#example-milestone",
    "href": "milestones.html#example-milestone",
    "title": "GitHub Milestones",
    "section": "Example Milestone",
    "text": "Example Milestone\nMilestones can help you keep track of concrete goals like version releases, which is useful when you’re thinking about the next feature to accomplish for a specific project.\nHere is an example of what a milestone can look like:\n\n\n\nA milestone has been opened for this repository to keep track of an R package’s resubmission to CRAN. This resubmission is about 75% of the way there, with 1 open issue and 3 closed ones.\nOnce you click on a milestone, you can see more details about the issues that need to be closed before the milestone is 100% complete.",
    "crumbs": [
      "Project Management",
      "GitHub Milestones"
    ]
  },
  {
    "objectID": "milestones.html#creating-milestones",
    "href": "milestones.html#creating-milestones",
    "title": "GitHub Milestones",
    "section": "Creating Milestones",
    "text": "Creating Milestones\nOnce you’re ready to create a milestone, navigate to your repository and go to the “Issues” tab.\nClick on “Milestones”.\n\n\n\nThen click on either the “New milestone” or “Create a milestone” button if you haven’t created a milestone yet.\n\n\n\nFill out some information about your milestone, such as the title, due date (if any), and description. Click on “Create milestone” once you’re done.\n\n\n\nYou can always go back to the “Milestones” page and click “Edit” if you need to edit the title, due date, or description.\n\n\n\nTo add issues/pull requests to your milestone, you can click on your milestone and add them directly there.\n\n\n\nOr you can go to your issues/pull requests page and select the checkboxes next to the issues/pull requests you want to associate with a milestone. Then click on the “Milestone” dropdown menu to add them to the milestone.\n\n\n\nFor more information on milestones, check out its GitHub documentation page.",
    "crumbs": [
      "Project Management",
      "GitHub Milestones"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This workshop provides an overview of what “version control” systems are and how they fit into collaborative coding within your team. Specifically, we are focusing here on an introductory approach to version control that focuses on using GitHub either through a browser or through software installed on your computer. We are always happy to improve workshop content so please don’t hesitate to post an Issue on our GitHub repository if you see clear areas for improvement!",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "index.html#workshop-preparation",
    "href": "index.html#workshop-preparation",
    "title": "Overview",
    "section": "Workshop Preparation",
    "text": "Workshop Preparation\nTo maximize the value of this workshop to you, we recommend that you take the following steps before the day of the workshop. You may have already completed some or all of these steps but please read through and confirm that you’ve done all of the steps that are relevant to you to ensure that all participants arrive with a common foundation of installed programs. If anything is unclear, feel free to reach out to us; our contact information can be found in the “SciComp Team” dropdown menu in the “People” page.\n\n\n\n\n\n\nNoteInstitution-Owned Computers\n\n\n\nIf your institution has a dedicated IT team that has sole power to install software on your computer, you will need to contact them before the workshop to do the installation bits of the prep steps we outline below.\n\n\nThere are a couple of distinct use-cases you might have for GitHub that will affect what preparation you need to do before this workshop. Consider the tabs below and follow all of the numbered steps in the choice that best fits your needs.\n\nGitHub with a BrowserGitHub with RStudioGitHub with Positron\n\n\n\n1. Create a GitHub Account\nStart by creating an account on GitHub. GitHub is how you’ll be able to collaborate with others in a way that tracks changes over time while facilitating a range of project management tools.\nDr. Jennifer Bryan has some nice guidelines for picking a good username so choose carefully when you make your profile. We also recommend adding a picture of yourself so that group members can more confidently identify one another on GitHub.\n\n\n2. Celebrate!\nAfter following all the previous preparation steps, your setup should now be complete.\n\n\n\n\n\n\n\n\n\nNoteRunning Code in Following Steps\n\n\n\nThe below preparation steps includes some code for making sure everything is installed as it should be. All code is either R code () or is command line code (). In either case, you’ll run all provided code in RStudio.  R code should be run in the “Console” tab of RStudio while  command line code should be run in the “Terminal” tab of RStudio.\nIf you get errors with the provided code, double check that you are running it in the right place!\n\n\n\n1. Create a GitHub Account\nStart by creating an account on GitHub. GitHub is how you’ll be able to collaborate with others in a way that tracks changes over time while facilitating a range of project management tools.\nDr. Jennifer Bryan has some nice guidelines for picking a good username so choose carefully when you make your profile. We also recommend adding a picture of yourself so that group members can more confidently identify one another on GitHub.\n\n\n2. Install R\nNow you should install R on your computer. If you already have R, check that you have at least version 4.0.0 by looking at the “Console” of your IDE of choice.\nIf your version starts with a “3”, please update R to make sure all packages behave as expected.\n\n\n3. Install RStudio\nOnce you have R (ver. ≥4.0), install RStudio. If you already have RStudio installed, you may want to make sure that you’re using a recent version to take advantage of some quality of life improvements that are broadly useful.\n\n\n4. Install Git\nYou can now install Git! Git is the software that actually does the behind-the-scenes version control operations we’ll cover in this workshop. Installing Git differs slightly depending on your operating system so check out the tabs below for the right option for you. These instructions are modified from Jennifer Bryan’s excellent “Happy Git and GitHub for the useR” ebook.\n\n Mac Windows Linux\n\n\nRun the following  command line code.\nxcode-select --install\nFor more detailed instructions, see here.\n\n\nInstall Git for Windows (a.k.a. “Git Bash”). When asked about “Adjusting your PATH environment”, select “Git from the command line and also from 3rd-party software”.\nFor more detailed instructions, see here.\n\n\nInstall Git via your distro’s package manager (in the  Terminal).\nIf you use Ubuntu or Debian Linux that  code is as follows:\nsudo apt-get install git\nIf instead you use Fedora or RedHat Linux the  code is instead:\nsudo yum install git\nFor more detailed instructions, see here.\n\n\n\n\n\n5. Check that Git’s Installation Worked\nRegardless of your operating system, once you’ve installed Git, check that worked with the following  command line code. All operating systems should be able to run this code.\nwhich git\nRStudio should also be able to detect Git so let’s check from that side too. In RStudio click through the following menus: “Tools”  “Global Options”  “Git / SVN” (cardboard box icon in left sidebar). If you see a file path under “Git executable” then you are good to go!\nIf Git was not detected, this may be caused by having your RStudio session open while you installed Git for the first time. In that case, please close and restart RStudio before checking again.\n\n\n6. Connect RStudio/Git and GitHub\nThe last step to take before you’re all set for the workshop is to get these components talking to one another! You set a password for your GitHub which is used for logging in to GitHub but to actually put your code changes from your computer up to GitHub you’ll need to authenticate yourself. There are two paths for authentication:\n\nPersonal Access Token (PAT)\nSecure Shell (SSH)\n\nWhat’s the difference? Essentially, authenticating via token makes many things “just work” while authenticating via SSH will work for some things but in other contexts you would also need to do token-based authentication. For a more complete discussion of the benefits and drawbacks of each, see Dr. Bryan’s “HTTPS versus SSH” page.\nFollow the steps of your chosen authentication method in the tabs below.\n\nTokenSSH Key\n\n\nAll of the code chunks for authenticating with a token are  R code that should be run in the “Console” pane of RStudio. You may also create a script and run the code from there if you so desire but you’ll likely only need this code once so the script’s value would be short-lived.\n\n\n“Classic” versus “Fine-Grained” Tokens\n\nIf you follow the steps outlined below, you will make a “classic” token. This is the recommended method! GitHub also supports “fine-grained” tokens but they are a little more error-prone for the ways working groups tend to use GitHub.\nFor all the nitty gritty detail, check out GitHub’s documentation on tokens but essentially fine-grained tokens only work for repositories that you personally own. Because LTER working groups tend to work primarily in a repository owned by the LTER Network Office GitHub Organization, this means that a fine-grained token won’t let you edit your group’s repository.\nSo, make sure that you make a “classic” token! Feel free to reach out to the SciComp team if questions arise on this point!\n\n\n# Install the `usethis` and `gitcreds` packages\ninstall.packages(c(\"usethis\", \"gitcreds\"))\n\n# Add your GitHub username and email\nusethis::use_git_config(user.name = \"Your GitHub Username\",\n                        user.email = \"Your GitHub Email\")\n\n# Create a token (Note this will open a GitHub browser tab)\n## See steps 6-10 in GitHub's PAT tutorial (link below)\n1usethis::create_github_token()\n\n\n1\n\nLeave parentheses empty\n\n\n\n\nCopy your token at the end of the above step. Once you leave the page where your token is displayed you’ll never get to see it again! So if you close that page without copying it you’ll need to make a new one in order to continue.\nOnce you’ve copied your token, run the code below to save your credentials in RStudio.\n\n# Now, give your token to RStudio\n## After you run this line follow the prompts in the \"Console\" tab of RStudio\n2gitcreds::gitcreds_set()\n\n\n2\n\nLeave parentheses empty here as well!\n\n\n\n\nThis line of code will prompt you to paste your token in the “Console” tab. After you do so (and hit “Enter”), your token will be safely stored in RStudio!\n\nFurther Information\nYou may also find GitHub’s PAT tutorial (this is the link referenced in the first token-authentication code chunk!) or the Happy Git with R PAT tutorial helpful.\n\n\n\nAll of the code chunks for authenticating with SSH are  command line code that should be agnostic to your programming language.\nFirst, we need to check whether you already have SSH keys created on your computer. If you get a message saying that nothing exists or the path doesn’t exist, you do not (yet) have SSH keys.\n\nls -al ~/.ssh/\n\nIf you do need to create an SSH key pair you can do so via the command line. When you create a key pair you’ll need to include a descriptive comment to help ‘future you’ if you ever have multiple key pairs in your life. We recommend “lter” plus your GitHub username to keep things simple.\n\nssh-keygen -t ed25519 -C \"lter-github\"\n\n\n\n\n\n\n\nTipOlder Computer?\n\n\n\nIf you get a warning/error because your system is too old to support the Ed25519 algorithm (that’s the variant recommended by GitHub) you can instead use:\n\nssh-keygen -t rsa -b 4096 -C \"lter-github\"\n\n\n\nAccept the prompt to save the key in the default location by hitting Enter. You will be prompted to enter a passphrase that will be required to access your SSH key later on. This step is technically optional but is considered a best practice. If SSH keys are totally new to you, we recommend skipping the passphrase step.\nOnce you’ve generated the key pair, follow GitHub’s instructions on adding that key pair to your computer’s ssh-agent (roughly equivalent to a password manager but just for SSH key pairs).\nFinally, you need to share the public key with your GitHub self. Once again we’ll refer you to the phenomenal materials generated by Dr. Bryan on this topic.\n\nFurther Information\nYou may also find GitHub’s SSH documentation or the Happy Git with R SSH tutorial helpful.\n\n\n\n\n\n\n7. Celebrate!\nAfter following all the previous preparation steps, your setup should now be complete.\n\n\n\n\n\n\n\n\n\nNotePositron vs. Visual Studio Code\n\n\n\nVisual Studio Code (a.k.a. VS Code) is an IDE favored by many software developers. Positron itself is actually a “fork” of VS Code’s software! However, Positron offers some additional functionalities to support R users and–given that most working group members are primarily R coders if they code–Positron is what we will be using in this workshop.\nHowever, if you are a VS Code user, much of the Positron content will actually work for you with some (or potentially no) adjustment.\n\n\n\n1. Create a GitHub Account\nStart by creating an account on GitHub. GitHub is how you’ll be able to collaborate with others in a way that tracks changes over time while facilitating a range of project management tools.\nDr. Jennifer Bryan has some nice guidelines for picking a good username so choose carefully when you make your profile. We also recommend adding a picture of yourself so that group members can more confidently identify one another on GitHub.\n\n\n2. Install R\nNow you should install R on your computer. If you already have R, check that you have at least version 4.0.0 by looking at the “Console” of your IDE of choice.\nIf your version starts with a “3”, please update R to make sure all packages behave as expected.\n\n\n3. Install Positron\nOnce you have R (ver. ≥4.0), install Positron. If you already have Positron installed, you may want to make sure that you’re using a recent version to take advantage of the features available in the most recent version.\n\n\n4. Install Git\nYou can now install Git! Git is the software that actually does the behind-the-scenes version control operations we’ll cover in this workshop. Installing Git differs slightly depending on your operating system so check out the tabs below for the right option for you. These instructions are modified from Jennifer Bryan’s excellent “Happy Git and GitHub for the useR” ebook.\n\n Mac Windows Linux\n\n\nRun the following  command line code.\nxcode-select --install\nFor more detailed instructions, see here.\n\n\nInstall Git for Windows (a.k.a. “Git Bash”). When asked about “Adjusting your PATH environment”, select “Git from the command line and also from 3rd-party software”.\nFor more detailed instructions, see here.\n\n\nInstall Git via your distro’s package manager (in the  Terminal).\nIf you use Ubuntu or Debian Linux that  code is as follows:\nsudo apt-get install git\nIf instead you use Fedora or RedHat Linux the  code is instead:\nsudo yum install git\nFor more detailed instructions, see here.\n\n\n\n\n\n5. Connect Positron/Git and GitHub\nThe last step to take before you’re all set for the workshop is to get these components talking to one another! One reason to use Positron instead of RStudio is because of how much simpler this step is for Positron. Instead of needing to write code, we can do a little authentication dance with buttons in the browser and afterwards, everything will ‘just work.’\nTo begin, open Positron. You should have a screen that looks something like the below screen capture. Note that you might be in “light mode” depending on your computer settings but that should not affect which buttons to click or where they can be found.\n\n\n\nFrom there, go to the left sidebar and click the branch icon (  ). It should be the third option from the top. Once you are there, click “Clone Repository”.\n\n\n\nThis should automatically open the search bar in the top middle of Positron and present you with a single option titled “Clone from GitHub”. Click that option.\n\n\n\nOnce you’ve clicked that option, you should be presented with the following pop up where Positron is telling you that Positron’s GitHub extension wants to talk to the online version of GitHub. Click “Allow”.\n\n\n\nPositron will now allow provide you with a code of random letters/numbers that you’ll need to share with GitHub. Helpfully, a new pop-up will appear where one of the options is “Copy & Continue to Github”; click that option.\n\n\n\nOnce you click “Copy & Continue to Github” button, you should automatically be sent to your default web browser application and be prompted to choose which GitHub account to use. Most users will have only one option so go ahead and click “Continue” next to that profile.\n\n\n\nYou’ll next need to put in the code that you got from Positron. You should be able to simply paste it in because you just copied it! After you’ve entered the code, click “Continue”.\n\n\n\nGitHub will now provide you with a list of the permissions that Positron is asking for and ask you to approve them. These permissions are required for you to work with Positron so feel free to read through them but ultimately you must scroll down and click “Authorize”.\nIf you are a member of any GitHub organizations, they will be listed below the list of requested permissions but you should just ignore those and scroll past them.\n\n \n\n\n\n\n\n\n\nNoteGitHub Login Prompt\n\n\n\nIf you have not recently logged in to GitHub, you will be sent to the standard GitHub login page. If you are sent there, log in as normal (i.e., either by using your username/password or with the 2FA option provided by the GitHub Mobile app).\n\n\nOnce you’ve worked through the above step, you should get a confirmation page from GitHub that looks like the following screen capture.\n\n\n\nYou will know that you’ve followed these steps correctly if, when you return to Positron, the search bar in the top middle (that said “Clone from GitHub” before) now has a list of repositories to which you have access.\n\n\n\n\n\n6. Celebrate!\nAfter following all the previous preparation steps, your setup should now be complete.",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "index.html#github-science-publications",
    "href": "index.html#github-science-publications",
    "title": "Overview",
    "section": "GitHub + Science Publications",
    "text": "GitHub + Science Publications\nThe reproducibility and collaborative benefits of GitHub for working scientists is well appreciated and increasingly well published upon. See below for brief synopses of papers published in this realm that we think may resonate with your team’s disciplinary backgrounds and motivations.\nIn the ecology and evolutionary biology sphere, Pereira Braga et al. published “Not just for programmers: How GitHub can accelerate collaborative and reproducible research in ecology and evolution” in Methods in Ecology & Evolution. This paper is a phenomenal resource for ecologists and evolutionary biologists who are considering the value of GitHub to them in and outside of a working group context. The authors identify 12 uses of GitHub for the EEB community and arrange them by technical difficulty (ranging from beginner to advanced) and degree of collaboration (low to high). We have embedded this paper’s second figure in this website below as it is a neat summarization of many of their central points. That said, we definitely recommend reading (and citing!) Pereira Braga et al. 2023 for more detail than we’ve included in this blurb.\nIf you are concerned about the technical side of GitHub for yourself and/or your lab group, we recommend focusing on the lower technical difficulty benefits of GitHub (see the blue bars). We also think that some of the intermediate technical difficulty uses (orange bars) may be relevant to working group priorities and goals.",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "git-ignore.html",
    "href": "git-ignore.html",
    "title": "The .gitignore",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCreate a “.gitignore” in a repository using a GitHub template\nExplain the purpose of a “.gitignore” in collaborative projects\nEvaluate the content you think might warrant adding to the “.gitignore”",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#module-learning-objectives",
    "href": "git-ignore.html#module-learning-objectives",
    "title": "The .gitignore",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCreate a “.gitignore” in a repository using a GitHub template\nExplain the purpose of a “.gitignore” in collaborative projects\nEvaluate the content you think might warrant adding to the “.gitignore”",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#overview",
    "href": "git-ignore.html#overview",
    "title": "The .gitignore",
    "section": "Overview",
    "text": "Overview\nA “.gitignore” is a file you can use to tell Git what not to track. Any file/folder whose name is in the “.gitignore” will not be tracked by Git. This is useful if you want to include data in your local version of your repository but don’t want to risk sharing that data by committing it to a public GitHub repository. This file exists at the top level of every repository and can be customized however is most useful to you and your collaborators.",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#creating-a-.gitignore",
    "href": "git-ignore.html#creating-a-.gitignore",
    "title": "The .gitignore",
    "section": "Creating a “.gitignore”",
    "text": "Creating a “.gitignore”\nWhen you first create a repository you will have the opportunity to select a template “.gitignore” based on the coding language you plan on using. During the process of creating a repository, you can choose one of the templates curated by GitHub for a variety of coding languages. These templates exclude some typical machine-readable files that–while necessary for standard IDEs/background tasks–are not meaningful to track with version control.\nTo add a “.gitignore” during the repository creation phase, simply click the dropdown menu and start typing the name of your coding language. Unfortunately for R users, typing just “R” returns all templates that contain the letter ‘r’ so you will need to scroll a bit to find the option that is actually for the R language. Once you find the template you want, click it and the template dropdown should change from “.gitignore template: None” to “.gitignore template: &lt;your pick&gt;”.\n\n \n\nIf you create a repository without choosing a “.gitignore” template, don’t worry: you can always create one later! If you want to create a “.gitignore” in an extant repository that lacks one, run the relevant command line code for your computer’s operating system in your IDE’s  “Terminal” pane.\n\n Mac /  Linux Windows\n\n\ntouch .gitignore\n\n\ncopy NUL .gitignore\nIf copy NUL does not work, try touch instead.",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#using-a-.gitignore",
    "href": "git-ignore.html#using-a-.gitignore",
    "title": "The .gitignore",
    "section": "Using a “.gitignore”",
    "text": "Using a “.gitignore”\nA classic use-case for a “.gitignore”–as previously mentioned–is to ignore any data files that you have in your working directory but that you don’t want Git to track of GitHub to store. In general, script inputs and outputs should not be tracked by Git or put in GitHub. Versioning of tabular data doesn’t really work very well and it’ll clutter your GitHub repository with data files that you already have access to elsewhere.\nAdditionally, storing script inputs/outputs both on GitHub and elsewhere (e.g., Google Drive, Dropbox) undermines the “single source of truth” and dramatically increases the risk that you accidentally work with a superseded input file and get incorrect results.\nTaken together, the following demonstration of how to use a “.gitignore” will focus on ignoring a new data file in the working directory. This file is informatively named “data.csv”.\n\nIn RStudioIn Positron\n\n\nTo begin, we can check the Git pane of RStudio to confirm that Git does see “data.csv” even though Git is not tracking it currently.\n\n\n\nWith that confirmed, click over to the “Files” pane. Because the “.gitignore” file starts with a period, it is likely invisible to your standard file explorer program but RStudio’s “Files” pane does see it and easily lets you interact with it.\n\n\n\nIn the “Files” pane, click the “.gitignore” to open it. If you scroll through you can see that the template from GitHub includes a number of files, many of which you may never have seen (again, often because they start with a period and are thus not easily visible).\n\n\n\nWhile currently we only have “data.csv” in our working directory, we can safely assume that we don’t want any CSVs to be tracked by Git. So, rather than entering “data.csv” into the “.gitignore”, let’s add a wildcard for all CSVs by entering “*.csv” at the bottom of the “.gitignore”. Note that in the below screen shot, we haven’t saved our edits to the “.gitignore” so the “Git” pane still (1) shows “data.csv” and (2) does not show any modifications to the “.gitignore”.\n\n\n\n\n\n\nNoteComments in the “.gitignore”\n\n\n\nYou can enter comments in the “.gitignore” in the same way you would in R/Python code: by adding a # to the start of the line. This can be helpful if you want to add small documentation of what is being ignored or why it is being ignored.\n\n\n\n\n\nOnce you save the edits to the “.gitignore”, you’ll notice that the Git pane automatically updates to (1) no longer show “data.csv” and (2) show that the “.gitignore” has been modified since the last commit. You can then commit and push your edits to the “.gitignore” in the same way you would edits to any other file.\n\n\n\n\n\nTo begin, we can check the “source control” pane of Positron to confirm that Git does see “data.csv” even though Git is not tracking it currently.\n\n\n\nWith that confirmed, click over to the “Explorer” pane. Because the “.gitignore” file starts with a period, it is likely invisible to your standard file explorer program but Positron’s “Explorer” pane does see it and easily lets you interact with it.\n\n\n\nIn the “Explorer” pane, click the “.gitignore” to open it. If you scroll through you can see that the template from GitHub includes a number of files, many of which you may never have seen (again, often because they start with a period and are thus not easily visible).\n\n\n\nWhile currently we only have “data.csv” in our working directory, we can safely assume that we don’t want any CSVs to be tracked by Git. So, rather than entering “data.csv” into the “.gitignore”, let’s add a wildcard for all CSVs by entering “*.csv” at the bottom of the “.gitignore”. Note that in the below screen shot, we haven’t saved our edits to the “.gitignore” so the “source control” pane still (1) shows “data.csv” and (2) does not show any modifications to the “.gitignore”.\n\n\n\n\n\n\nNoteComments in the “.gitignore”\n\n\n\nYou can enter comments in the “.gitignore” in the same way you would in R/Python code: by adding a # to the start of the line. This can be helpful if you want to add small documentation of what is being ignored or why it is being ignored.\n\n\n\n\n\nOnce you save the edits to the “.gitignore”, you’ll notice that the source control pane automatically updates to (1) no longer show “data.csv” and (2) show that the “.gitignore” has been modified since the last commit. You can then commit and push your edits to the “.gitignore” in the same way you would edits to any other file.",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#ignoring-previously-tracked-content",
    "href": "git-ignore.html#ignoring-previously-tracked-content",
    "title": "The .gitignore",
    "section": "Ignoring Previously Tracked Content",
    "text": "Ignoring Previously Tracked Content\nImagine a situation where you commit a file that you don’t want Git to track and push that commit before realizing your mistake. Now that file is tracked by Git and every time you alter that file, it will show up in your IDE’s version control pane. If you add the file to your “.gitignore” now, you won’t be able to delete it because Git will stop tracking new changes (even deletions).\nTo resolve this, do the following:\n\nDelete the offending file(s)\n\nIf you don’t want to actually delete them, just move the file(s) out of the folder tracked by Git and move them back after step 3\n\nCommit the deletion\nAdd the file(s) to the “.gitignore”\nCommit the change to the “.gitignore”\npush/sync your changes with GitHub",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "git-ignore.html#lter-scicomp-recommendations",
    "href": "git-ignore.html#lter-scicomp-recommendations",
    "title": "The .gitignore",
    "section": "LTER SciComp Recommendations",
    "text": "LTER SciComp Recommendations\nThere are many different opinions on what should go into a “.gitignore” but see below for some recommendations of things to ignore from the makers of this workshop. Feel free to disregard any that you don’t feel apply to your needs.\n\nStart with the GitHub Template\nWhen you create a repository, use GitHub to add the template “.gitignore” for your chosen programming language. There are a lot of small files that typical users don’t care about that your project will accumulate over its lifecycle. If you don’t flag these in the “.gitignore” it can become difficult to sort through your repository.\n\n\nIgnore Script Inputs and Outputs\nVersion control is only meant to track code files so everything else should be ignored. You should store your inputs somewhere that your collaborators can access them and–at the end of your project–archive them in a FAIR (Findable, Accessible, Interoperable, and Reusable) repository. Anyone wanting access to script outputs should be able to use those inputs to run the code themselves and generate them. Alternately, you may also want to upload script outputs to some static platform (e.g., Google Drive, Dropbox) so non-coders can easily access them there. In either case, Git should not be used to track/store anything other than code files.\nOne way of doing this fairly efficiently is to create dedicated folders for storing inputs or outputs (e.g., “data/”, “graphs/”, “results/”) and then add those folder names to the “.gitignore”. You could also ignore certain file types–as demonstrated above–if your inputs/outputs belong to a relatively small set of file types.\n\n\nIgnore the “.DS_Store” File\nIf you are a  Mac user, you should ignore the “.DS_Store” file. Macs create a “Desktop Services Store” file (or “.DS_Store” for short) every time you open a folder. This file is invisible in your file manager but can be committed. This file has no practical value in your project and a separate one exists in every subfolder so tracking them can quickly clutter a repository if you use subfolders.\n\n\nIgnore the R Project File\nIf you are an RStudio user, you should ignore the “.Rproj” file. This opinion is a relatively contentious one as RStudio users are deeply divided on whether to ignore this file or commit it. We recommend ignoring it for two reasons:\n\nIf you commit your .Rproj file and someone later deletes it, the next time you pull, Git will delete your .Rproj file and cause RStudio to unexpectedly quit–costing you all of your uncommitted edits. You will then need to create a new .Rproj in the desired folder and re-connect it to Git/GitHub.\nAll group members may have different names for their .Rproj files which means you could have as many of these files in your GitHub repository as there are collaborators. This is cumbersome to sort through and attempts to fix this post hoc run the risk outlined in the first point.\n\nIf these risks are not sufficient to sway you, consider that the .Rproj file serves almost no purpose in the first place. In theory, the .Rproj file can be used to define some RStudio settings for anyone who uses that .Rproj but few R users actually use it for this purpose and instead mostly use it as a shortcut to open the relevant project in RStudio.\nUltimately, this is up to you and your team to decide! Hopefully the rationale we provided above helps inform this decision and we are happy to discuss this more if you have follow up questions.",
    "crumbs": [
      "Advanced Topics",
      "The .gitignore"
    ]
  },
  {
    "objectID": "forks.html",
    "href": "forks.html",
    "title": "Forks",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “fork” in the context of Git/GitHub\nContrast forks with branches\nUse the fork feature on GitHub for an existing repository",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "forks.html#module-learning-objectives",
    "href": "forks.html#module-learning-objectives",
    "title": "Forks",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “fork” in the context of Git/GitHub\nContrast forks with branches\nUse the fork feature on GitHub for an existing repository",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "forks.html#what-is-a-fork",
    "href": "forks.html#what-is-a-fork",
    "title": "Forks",
    "section": "What is a Fork?",
    "text": "What is a Fork?\nA fork is a duplicate of a Git repository that is owned by someone other than you. Any repository that you can view on GitHub, you can fork. Forks allow you to start with a complete repository and then edit it for your own use as needed.\nThe difference between forks and branches is a source of great confusion for many (even veteran!) Git users but hopefully this list helps to clarify:\n\nA fork creates a new repository while a branch exists within a given repository\nA fork is owned by a different user/organization than the original, a branch does not change repository ownership\nA fork’s “parent” repository is not recognized by Git but Git does ‘know’ which branch a given branch originates from.",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "forks.html#choosing-whether-to-fork-or-to-branch",
    "href": "forks.html#choosing-whether-to-fork-or-to-branch",
    "title": "Forks",
    "section": "Choosing Whether to Fork or to Branch",
    "text": "Choosing Whether to Fork or to Branch\nA good rule of thumb for whether you should fork or branch a repository is based on whether you’re working independently from the owner of the repository versus collaborating actively with them.\nIf you are largely independent from the repository’s owner, fork that repository to get your own copy to independently work in. If you are actively collaborating, it is likely that you’ll want to work in a branch.\nIt is important to note that both forks and branches can be merged back into their source (the “main” branch for branches and the original repository for forks) via pull request so you need not worry that choosing one or the other will preclude integration with the source.",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "forks.html#brief-overview-of-fork-workflow",
    "href": "forks.html#brief-overview-of-fork-workflow",
    "title": "Forks",
    "section": "Brief Overview of Fork Workflow",
    "text": "Brief Overview of Fork Workflow\nForking is (arguably) one of the more straightforward Git workflows but before we cover it in detail, let’s review the broader context.\nYou begin by going to the GitHub page for a repository that you do not own. From there, there is a convenient “Fork” button you can click that (after a screen very much like that of creating a new repository) creates a duplicate of the repository in your profile’s repository list.\nOnce the fork is created, you simply clone the repository as you would when beginning work with any other GitHub repository.\nFrom there on you work as your normally would with GitHub: edit, commit, pull, and push.\nWhile it is not shown in the below diagram, if needed you can submit a “pull request” (see Appendix B: Branches) to merge your version of the repository with the version you initially forked from. This is not a required part of the workflow which is why it is excluded from the diagram.\n\n\n\nNow we’ve covered the general operation of forking, let’s go over the specifics step-by-step.",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "forks.html#create-a-fork",
    "href": "forks.html#create-a-fork",
    "title": "Forks",
    "section": "Create a Fork",
    "text": "Create a Fork\nOn GitHub, navigate to the repository that you would like to fork for your own use. Note that in this case the repository we created to take these screen captures is very new but this need not be the case!\nIn the top right of the repository’s GitHub page there is a “Fork” button (between “Unwatch” and “Star”), click it to begin forking.\n\n\n\nThis redirects you to a page that is very similar to the page for creating a new repository de novo.\nHere you can select who you want to own the repository from a dropdown including any organizations you are a member of and your username if you want to personally own the fork. You can also change the repository name (though the default is to retain the same name) and add a description of your purpose for the fork.\nYou may notice that in this page you do not have the option to specify public versus private or any of the ‘initialize’ steps (e.g., README, gitignore, or licence). Forks will inherit these settings from the repository they are forked from so they do not need to specified here.\nOnce you are happy with the owner of the fork, the name, and the description, click the green “Create fork” button.\n\n\n\nDepending on the amount of content in the repository you are forking and your internet speed this may take anywhere from a few seconds to 1-2 minutes so you will need to wait for a moment while GitHub creates a new duplicate repository under the control of the owner you specified.\nAfter the process completes the page will refresh and you will find yourself on the landing page for your new forked repository!\n\n\n\nThis repository has a fork icon in the top left (to the left of the owner/repository name) and includes a link to the repository that it came from just beneath that.\nThe other salient difference is that between the branch and “Code” buttons and the list of files there is a bar that indicates whether the fork is up to date with the repository it was forked from.\nIf the “parent” repository is updated (i.e., someone pushes changes to it after you forked) you can click the “Fetch upstream” button to integrate those changes with your fork.\nIf you decide that your changes are a meaningful improvement that the parent repository could benefit from, you can click the “Contribute” button to begin the process of submitting a pull request to integrate your edits with the parent (see Appendix B: Branches for instructions on submitting a pull request).\nFrom here on you can work within your fork as you would within any other repository! Clone the fork into your local computer and work as you normally would.",
    "crumbs": [
      "Advanced Topics",
      "Forks"
    ]
  },
  {
    "objectID": "browser.html",
    "href": "browser.html",
    "title": "Using GitHub with a Browser",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nNavigate GitHub via a web browser\nUse GitHub to create a new repository\nEdit a new repository through GitHub’s interface",
    "crumbs": [
      "Using GitHub...",
      "With a Browser"
    ]
  },
  {
    "objectID": "browser.html#module-learning-objectives",
    "href": "browser.html#module-learning-objectives",
    "title": "Using GitHub with a Browser",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nNavigate GitHub via a web browser\nUse GitHub to create a new repository\nEdit a new repository through GitHub’s interface",
    "crumbs": [
      "Using GitHub...",
      "With a Browser"
    ]
  },
  {
    "objectID": "browser.html#exploring-github",
    "href": "browser.html#exploring-github",
    "title": "Using GitHub with a Browser",
    "section": "Exploring GitHub",
    "text": "Exploring GitHub\nLet’s navigate over to GitHub and explore some of its features. Here is what the home screen looks like as of February 2022.\n\n\n\n\n\n\nNoteGitHub Button Color\n\n\n\nDepending on your GitHub settings, key buttons will either be green or blue. This has no functional effect but is mentioned here just to note that some of the screen captures in this workshop will show green buttons while others have blue buttons.\n\n\n\n\n\nLog in with your GitHub account that you should have created prior to this workshop.\n\n\n\nOnce you’ve logged in, you should see something like this:\n\n\n\nThis landing page has a nice summary of your recent repositories and activity on the left panel. Click on your icon at the top left corner and navigate to your profile.\n\nYour GitHub Profile\nYour profile page shows the organizations that you’re a part of, as well as a more detailed view of your GitHub contributions/activities over time. There are also tabs at the top that lead you to your repositories, projects, packages, and starred repositories.\n\n\n\nIf you would like, you can change your GitHub theme to dark mode by clicking on your icon at the top left corner and going to Settings then Appearances. For the purposes of this workshop, the rest of the screenshots for the GitHub website will be in dark mode to differentiate it from RStudio.\n\n\n\nIf there is anything else you would like to change about your account, the user settings page should have it.",
    "crumbs": [
      "Using GitHub...",
      "With a Browser"
    ]
  },
  {
    "objectID": "browser.html#looking-at-a-github-repository",
    "href": "browser.html#looking-at-a-github-repository",
    "title": "Using GitHub with a Browser",
    "section": "Looking at a GitHub Repository",
    "text": "Looking at a GitHub Repository\nTo check the repositories that you’ve created, click on the Repositories tab. Note that the top left corner has a green button that will allow you to create new repositories. We will come back to that later.\n\nRepository Content & Structure\nLet’s take a closer look at what the ucsb-ds-capstone-2021.github.io repository contains.\n\n\n\nThis screen shows the copy of a repository stored on GitHub, with its list of files, when the files and directories were last modified, and some information on who made the most recent changes.\n\n\n\nIf we look at the blue rectangle, we can see that there have been 151 commits made to this repository. By clicking on them, we can see the history of changes made to all of the files. Looks like 3 users were making changes in April.\n\n\n\nAnd finally, if we examine one of the changes made on April 25, we can see exactly what was changed in each file:\n\n\n\nThe red lines have been deleted while the green lines are new additions. Tracking these changes, and seeing how they relate to released versions of software and files is exactly what Git and GitHub are good for. We will show how they can really be effective for tracking versions of scientific code, figures, and manuscripts to accomplish a reproducible workflow.\n\n\nEditing a File in GitHub\nIt is possible to edit and add files entirely on the GitHub website, by navigating to the specific file or repository. To edit an existing file, simply navigate to the file you want to edit (in GitHub), and click the pencil icon above and to the right of the file’s contents.\n\n\n\nTo add a file, go to the home page of the repository and click the “Add file” dropdown (just to the left of the blue “Code” button) and choose the option that fits your needs. Note that you can only make new files in the ‘top level’ of the repository or in an existing folder so if you need to make a new folder, you’ll need to embrace using GitHub with an IDE (Integrated Development Environment).",
    "crumbs": [
      "Using GitHub...",
      "With a Browser"
    ]
  },
  {
    "objectID": "browser.html#creating-a-repository-on-github",
    "href": "browser.html#creating-a-repository-on-github",
    "title": "Using GitHub with a Browser",
    "section": "Creating a Repository on GitHub",
    "text": "Creating a Repository on GitHub\nYou can start the process of making a repository in GitHub. In fact, even if you plan on using GitHub via an IDE (e.g., RStudio, Visual Studio Code, Positron), we recommend starting the repository in GitHub before continuing to work in your IDE of choice.\nIn order to create a new repository, navigate to your profile page and click on the “Repositories” tab. Once you are there, click the “New” button in the upper right corner.\n\n\n\nYou will now be prompted to do some setup tasks before the repository can be created. First, choose a descriptive name for your new repository, here we named it git-practice but generally you’ll want a name that is short while still being descriptive so you can identify its purpose at a glance. Also, it is good practice to avoid uppercase letters and use - or _ instead of spaces.\nOnce you’ve named your repository, write a 1-sentence description about the repository content. Choose Public–this will prevent some easily avoidable access issues down the line.\nFinally, click the toggle next to “Add README”. This will create a nice file in the top-level of the repository that you can use for high-level documentation. That is extremely useful as a home for any explanation that the repository needs in order to be intelligible to ‘future you’ or your collaborators.\nNote that you may want to also add a .gitignore using the GitHub template for the code language that you plan to use (see the dropdown menu). This file is described in greater detail elsewhere in this workshop but essentially it is a list of files and folders that you don’t want Git to track or that you don’t want to upload to GitHub. The coding language templates mostly start by excluding machine-readable files that you don’t care about but that your IDE needs to function.\nOnce you’re happy with the details of your new repository, click “Create repository”.\n\n \n\nYay! We’ve just created a new repository! Here is what the landing page should look like:\n\n\n\nThis repository is currently public, so it’s visible to anyone, but since we are working in groups, we will need to give access to your group members. Click on the “Settings” tab for your repository and go to “Collaborators” in the left sidebar (second from the top).\n\n\n\nClick on “Add people” to empower your collaborators to edit things on this GitHub repository. That the repository is “public” only means that anyone with the link can see what’s in it; the repository owner must specifically grant edit access to the GitHub profiles that should have it.\nIn the resulting pop-up box (see below), type in each collaborator’s GitHub username and select them when they appear in the list.\n\n\n\n\n\n\n\n\n\nNoteImportance of GitHub Profile Picture\n\n\n\nThis is why it’s important to add a distinctive image to your GitHub profile! It helps whoever is adding collaborators to a given repository know that they’re adding the right people.\n\n\nGreat! Now everyone in the group should receive an invite to access that repository. The invite expires in 24 hours so be sure to send the invite during normal working hours and consider also emailing your team members to let them know they have a time-sensitive invite in whichever email inbox is tied to their GitHub account.\n\nPractice: Create Your Own Repository\nNow that we’ve walked through how to create a repository on GitHub let’s try to make our own! Click over to GitHub and create your own repository (with a README!). We’ll split into breakout groups to try this out and please let us know if any questions come up.",
    "crumbs": [
      "Using GitHub...",
      "With a Browser"
    ]
  },
  {
    "objectID": "branches.html",
    "href": "branches.html",
    "title": "Branches",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “branch” in the context of Git/GitHub\nSummarize the main steps of a workflow that uses branches\nCreate a branch on an existing repository",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#module-learning-objectives",
    "href": "branches.html#module-learning-objectives",
    "title": "Branches",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “branch” in the context of Git/GitHub\nSummarize the main steps of a workflow that uses branches\nCreate a branch on an existing repository",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#what-is-a-branch",
    "href": "branches.html#what-is-a-branch",
    "title": "Branches",
    "section": "What is a Branch?",
    "text": "What is a Branch?\nA “branch” is essentially a working environment in your Git repository that is separate from your main working area. This can be incredibly useful when you have a task to work on but you don’t want to risk damaging the version of your code that already works. Note that “branch” can be either a noun or a verb as with many of the Git vocabulary words discussed earlier (e.g., “commit”, “push”, etc.).\nBranches are typically created with the intent to put the work in the branch back into the main branch when you are done with it. Implicit in that rationale is the fact that most branches are created with a specific task/sub-task in mind and known to be temporary from the outset.\nAs an example, imagine that you want to put a better engine in your car but you don’t want to risk damaging your car as you go about that job. In Git terms you could create a branch to work on those mechanical improvements while at the same time preserving your original car separately (in the “main” branch). When you’re done experimenting and happy with the new version of your car, you can merge the two cars keeping all of the improvements you made in your branch.\nEven if you think you’ve never worked with Git branches you actually have! All Git repositories actually start in a branch named “main” so even if you’ve never intentionally created a branch, you’ve been working in your “main” branch all along.",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#branch-workflow-overview",
    "href": "branches.html#branch-workflow-overview",
    "title": "Branches",
    "section": "Branch Workflow Overview",
    "text": "Branch Workflow Overview\nBefore diving into the specifics of how to use branches while working with Git, let’s take a look at a general overview of that process.\nAs with many other Git operations, the first thing to do is pull from GitHub to your local repository to ensure that you’re working with the most up-to-date version of everything in the repo (see Step 1 below).\nOnce that is done, you can create a branch on your local machine. This will automatically shift your IDE into that new branch. Doing this on your machine also updates GitHub to show that there are multiple branches (see Step 2 below).\nOnce you have created a branch you can work in it locally (and via GitHub directly) as you would normally. You can edit your files locally, commit those changes, pull from GitHub (within the branch), and push to GitHub (see Steps 3-4 below).\nWhen you are done working with the branch (i.e., you’ve finished the task for which you created the branch), you can use GitHub to merge your branch with the main one (see Step 5 below). This puts all of the content in your branch into the main one now (which puts your local version of the “main” branch behind!).\nOnce the two branches are merged on GitHub, go back to your local computer, manually change the branch to the main branch and pull (see Step 7 below). This updates your local version of the main branch and avoids future problems.\nGiven that most branches are not used again after they are merged, it is often a good housekeeping step to then delete your branch on GitHub and locally once you have successfully merged the pull request (see Steps 6 & 8 below). Note that in the below diagram step 6 and 8 occur on either side of step 7 but in truth they can both come after depending on your preference.\nHowever, deletion of the branch either locally or via GitHub must come after step 5!\nAs you can see from the above text and the below diagram, branches have a few more moving parts than the Git and GitHub operations we’ve discussed so far. That said, they can be a powerful tool in service of collaborative work because you can have multiple branches active at the same all working on separate tasks. This approach can be an easy (or at least easier) workflow for working together while avoiding conflicts (again, see “Appendix A: Conflicts”).\n\n\n\nNow we’ve gone over this big picture overview, let’s walk step-by-step through creating, working in and ultimately merging branches!",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#create-a-branch",
    "href": "branches.html#create-a-branch",
    "title": "Branches",
    "section": "Create a Branch",
    "text": "Create a Branch\nBefore you create a branch, pull from/sync with GitHub as a precaution so that you are certain your local repository has the most up-to-date content. Failing to do so is a recipe for a brutal merge conflict when you are finished with your banch and want to merge it back into the main flow of your repository.\n\nIn RStudioIn Positron\n\n\nTo create a branch, click the purple button in the “Git” tab of RStudio that shows two rectangles connected by a diamond at right-angles from one another.\n\n\n\nIn the resulting dialogue box, give your new branch an informative name. In this example we haven’t given our new branch a great name but in a “real” repository you will greatly appreciate having concise but descriptive branch names. Once you’re happy with the name, click the “Create” button (you can ignore the other options and buttons on this dialogue box).\n\n\n\nThis will create a confirmation message that is superficially similar to the format of messages returned by other Git actions.\n\n\n\nYou may also notice that in your Git tab where previously it said “main” it now shows whatever name you chose for your branch.\n\n\nTo begin, go to the “source control” section of Positron.\n\n\n\nTo create a branch, hover over the “Changes” dropdown menu and click ... to expand the set of Git operations that are visible. From there, scroll down to “Branch” and click it. Finally, click “Create Branch…”.\n\n\n\nIn the resulting field (top middle of Positron), give your new branch an informative name. In this example we haven’t given our new branch a great name but in a “real” repository you will greatly appreciate having concise but descriptive branch names. Once you’re happy with the name, hit the Enter key on your computer.\n\n\n\nNow that you’ve made your new branch locally, you need to send it up to GitHub. Positron calls this “Publishing” but this isn’t conceptually different from any other sync/push–essentially you’re just letting GitHub know that you have a branch locally that it doesn’t have a record of yet. To publish the branch, click the “Publish Branch” button.\n\n\n\nYou’ll know that this worked when you look at the branch diagram in the bottom left corner of Positron’s source control menu. Note how the second commit from the top has the “origin/main” label while the top-most one has the label that matches whatever you named your new branch.",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#work-in-the-branch",
    "href": "branches.html#work-in-the-branch",
    "title": "Branches",
    "section": "Work in the Branch",
    "text": "Work in the Branch\nYou can now work in a branch in the same way that you work with GitHub via your IDE of choice when you are not using branches.\n\nMake edits\nCommit changes locally\nPull from GitHub to reduce the chances of a conflict\nPush your committed changes to GitHub\n\nThe reason you use the same workflow is–as previously stated–even if you don’t typically use branches, all work in Git is functionally done in the “main” branch of your repository so your work in this new branch should use the same order of operations as work done in the “main” branch.",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "branches.html#merging-branches",
    "href": "branches.html#merging-branches",
    "title": "Branches",
    "section": "Merging Branches",
    "text": "Merging Branches\nWhen you are done with your work in the branch, you will want to merge your new branch with the “main” branch of the repository. This branch merging is most easily done via GitHub so the following instructions are agnostic to IDE and purposefully exclude the repository name from the screen capture area. To start, push/sync your final commit(s) from your local branch with GitHub.\n\nOpen & Merge a Pull Request\nAfter you push/sync your changes, GitHub should recognize this and automatically create a button at the top of your repository’s home page for you to start the process of creating a “pull request.” Pull requests are how you merge branches on GitHub and the entire process is conducted entirely in the browser so we’ll leave our IDEs until the pull request is completed.\nTo start the branch merging process, click the “Compare & pull request” button\n\n\n\nYou will then be prompted to write a title and message for your pull request to give some broader context for what the branch does. This is especially valuable if you are not the one reviewing pull requests as this can help someone quickly familiarize themselves with what you have done.\nOnce you’re satisfied with your title and message, click the “Create pull request” button.\n\n\n\nThat done, GitHub will send you to a page that looks very much like a Github issue (see the module on issues for more detail). At the top is whatever title and message you just wrote when opening the pull request following by a list of all of the commits in that branch.\nThose commits are hyperlinks in case you want to view the specific differences to files edited in this branch.\nNote also that if you realize you forgot to do something in your branch (or if someone asks you change something) you can return to your IDE and commit/pull/push and it will automatically update on the pull request. Pull requests are for merging a whole branch, not for merging just a part of the work in the branch.\nYou or your team can also post messages on a pull request as needed (see the text box at the bottom of the below picture).\nIf you are ready to merge a pull request from your branch into the “main” branch click the “Merge pull request” button.\n\n\n\nGitHub will open another text box where you can add a commit message to your acceptance of the pull request. If whoever opened the pull request was sufficiently detailed in their opening comment(s) this may not need to be terribly detailed but it can’t hurt!\nOnce your message is written, click the “Confirm merge” button.\n\n\n\nYour pull request has now been merged! Now we need to do some minor housekeeping in GitHub that–fortunately–GitHub makes really accessible.\n\n\nGitHub Branch Housekeeping\nBranches are meant to be short-lived and deleted once the specific purpose for which they were created has been accomplished. So, once the pull request is merged, we should click the “Delete branch” button. This will ensure that the number of active branches remains manageable and also will let you re-use branch names later on if you deem that necessary.\n\n\n\nAfter you click “Delete branch” it will be replaced by a “Restore branch” button so you could always reclaim it if the deletion was premature.\n\n\n\nFinally, if we return to the home page of the repository, we can see that the most recent commit is whatever we put in the pull request text field right before we merged it.\n\n\n\n\n\nUpdate your Local Clone\nNow that the branches have been merged on GitHub, we need to make sure our local clone gets those updates from GitHub. This is particularly important if our IDE is still in the branch we created earlier because–now that we’ve deleted the branch’s counterpart in Github–we’ll get an error if we attempt to push from that branch.\n\nIn RStudioIn Positron\n\n\n\nGet Updates\nFirst, in the top right corner of RStudio, click the active branch name and switch to back to the “main” branch. Note that you may want to close your open files before doing this, particularly if some files were created in the branch because they wouldn’t yet exist in the “main” branch locally (you merged on GitHub with the pull request but haven’t pulled those updates locally).\n\n\n\nThis should create a message that looks like the following image. You should ignore the part of the message telling you that your are up to date; you are not up to date with GitHub yet. The message is referring to the status of your local clone’s version of the “main” branch.\n\n\n\nNow that you’re back in the “main” branch, pull the latest changes from GitHub. You should receive all of the commits that you just merged via pull request earlier. This will create a message that is something like the following image–though of course it will list all changed files so it may be a longer message than what is pictured below if you edited more files.\n\n\n\n\n\nBranch Housekeeping\nNow that our “main” branch is updated, we need to do the same sort of branch housekeeping that we did in GitHub after merging the pull request. In RStudio’s  “Terminal” pane, delete the finished branch with the following command line code. Remember to replace “BRANCH_NAME” with whatever you named your branch!\ngit branch -d BRANCH_NAME\nOnce you’ve deleted that branch, you’ll need to “prune” your branches. The previous code deleted the local version of your branch but your IDE still ‘thinks’ that GitHub has an equivalent of the branch. To reduce the potential for confusion, prune your local clone with the following command line code. Just like branch deletion, this should code should be run in RStudio’s  “Terminal” pane.\ngit remote update origin --prune\nYou can confirm that these two lines of code worked as expected by clicking the “main” branch name in RStudio’s Git pane. The resulting dropdown of local and remote branches should only list the “main” branch under each sub-heading.\n\n\n\n\n\n\nFirst, in the “source control” part of Positron, hover over the “Changes” menu and click ... to expand the set of Git operations that are visible. In the resulting dropdown, scroll down and click “Checkout to…”. Note that you may want to close your open files before doing this, particularly if some files were created in the branch because they wouldn’t yet exist in the “main” branch locally (you merged on GitHub with the pull request but haven’t pulled those updates locally).\n\n\n\nThis should open up a list of the available branches in the top middle of Positron. Find the “main” branch in the list of available branches and click it.\n\n\n\nNow that you’re back in the “main” branch, pull the latest changes from GitHub. You should receive all of the commits that you just merged via pull request earlier.\n\n\n\nYou will know this was successful when you look at the branch diagram at the bottom of the “source control” menu and see that the line for your experimental branch now re-connects to the leftmost branch’s line.\n\n\n\n\nBranch Housekeeping\nNow that our “main” branch is updated, we need to do the same sort of branch housekeeping that we did in GitHub after merging the pull request. In Positron’s  “Terminal” pane, delete the finished branch with the following command line code. Remember to replace “BRANCH_NAME” with whatever you named your branch!\ngit branch -d BRANCH_NAME\nOnce you’ve deleted that branch, you’ll need to “prune” your branches. The previous code deleted the local version of your branch but your IDE still ‘thinks’ that GitHub has an equivalent of the branch. To reduce the potential for confusion, prune your local clone with the following command line code. Just like branch deletion, this should code should be run in Positron’s  “Terminal” pane.\ngit remote update origin --prune\nYou can confirm that these two lines of code worked as expected by clicking the “Checkout to…” button in the dropdown menu of Git operations. The resulting list of branches should only list the “main” branch under each sub-heading.",
    "crumbs": [
      "Advanced Topics",
      "Branches"
    ]
  },
  {
    "objectID": "conflicts.html",
    "href": "conflicts.html",
    "title": "Conflicts",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the causes of merge conflicts\nExplain how to avoid merge conflicts\nSummarize what to do if a merge conflict occurs",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "conflicts.html#module-learning-objectives",
    "href": "conflicts.html#module-learning-objectives",
    "title": "Conflicts",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the causes of merge conflicts\nExplain how to avoid merge conflicts\nSummarize what to do if a merge conflict occurs",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "conflicts.html#merge-conflict-definition",
    "href": "conflicts.html#merge-conflict-definition",
    "title": "Conflicts",
    "section": "Merge Conflict Definition",
    "text": "Merge Conflict Definition\nMerge conflicts (a.k.a. “conflicts”) are a normal part of the Git workflow so don’t get discouraged when you run into them! They occur when Git cannot figure out how to automatically merge new changes together. The most common cause of a merge conflict is when you and a collaborator both edit the same lines in the same file and one of you pushes without first pulling the most recent version from GitHub.\nFor a visual demonstration of this, see the graphic below. Note that though this has visual similarity to the workflow diagrams that can be found throughout this website we do not recommend intentionally causing a merge conflict",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "conflicts.html#general-conflict-resolution-strategy",
    "href": "conflicts.html#general-conflict-resolution-strategy",
    "title": "Conflicts",
    "section": "General Conflict Resolution Strategy",
    "text": "General Conflict Resolution Strategy\nIf you encounter a conflict, Git will combine your local version of the conflicted file with its equivalent in GitHub. In order to resolve the conflict, you’ll need to manually tweak the local file(s) to decide what the script should look like then commit/push that file as normal.\nWe can see those steps visually in the following workflow diagram:",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "conflicts.html#fixing-conflicts",
    "href": "conflicts.html#fixing-conflicts",
    "title": "Conflicts",
    "section": "Fixing Conflicts",
    "text": "Fixing Conflicts\nIn order to make this discussion more grounded, we will demonstrate how a conflict can be repaired after one has been encountered. For context, the conflict shown below was caused by editing a file on GitHub (lyon-script.r), then editing the same line of that same file locally in our IDE and pushing without pulling first. If we had pulled before committing our local change, there would be no conflict!\n\nIn RStudioIn Positron\n\n\nAfter we attempt to push our local commit in RStudio, we get an intimidating dialog that looks like the following image. If we look at the lines of that message that start with hint: you can see that RStudio is warning us about why the push failed and how to go about fixing it in reasonably human-readable terms.\n\n\n\nLet’s follow RStudio’s advice and pull the latest changes from GitHub. This will cause another scary dialog about how the ‘automatic merge’ failed but this means we are on the road to a resolution.\n\n\n\nIf we look at the offending file, we’ll see a horrible-looking chimera file of the version we had locally versus what it looked like on GitHub before we attempted to push. You will see that Git inserted a line of &lt;&lt;&lt;&lt;, ====, and &gt;&gt;&gt;&gt; to encapsulate the version of the original lines we had locally versus what was on GitHub respectively.\n\n\n\n\n\n\n\n\n\nNoteFinding Conflicts in Long Scripts\n\n\n\nThese weird special lines can make finding merge conflicts in longs scripts much easier! Simply use your IDE’s search function to look for four &lt;&lt;&lt;&lt; next to one another as it is unlikely such a line would normally be included in your code.\n\n\nOnce Git has combined the two versions of the file, it is up to us to read through the script and edit it so that it looks right to us. At a minimum, this involves deleting the weird lines (in the screen capture below they are liens 1, 5, and 8) but in more difficult cases you may need to consider which version of the line is the one you want to retain.\nIn this case, we can retain both lines of code without damaging either so let’s just delete the special character lines.\n\n\n\nOnce you are confident you’ve fixed the conflict, commit the changes you made to resolve the conflict. This is done in the same way that you’d normally make a commit.\n\n\n\nBefore you push, take note that the Git pane is telling you that you are two commits ahead of ‘origin/main’. This is because both your original commit and your second commit (fixing the conflict) have yet to be pushed back up to GitHub–your first push failed because of the merge conflict. Once you’ve noted that, push your changes.\n\n\n\nYour RStudio should now look how it did before you got the conflict and you can continue working normally–hopefully having learned a lesson in proactive communication with your collaborators.\n\n\n\n\n\nAfter we attempt to sync our local commit in Positron, we get an intimidating warning about a merge conflict (see pop-up in the bottom right) and our script header is filled with gross special chacters in red text.\n\n\n\nBecause Positron’s default Git interaction is “sync” (a combination of a push and a pull) the local version of our script and the version on GitHub have already been auto-merged by Git. This means we are on the road to a resolution.\nIf we look at the offending file, we’ll see a horrible-looking chimera file of the version we had locally versus what it looked like on GitHub before we attempted to push. You will see that Git inserted a line of &lt;&lt;&lt;&lt;, ====, and &gt;&gt;&gt;&gt; to encapsulate the version of the original lines we had locally versus what was on GitHub respectively.\n\n\n\n\n\n\nNoteFinding Conflicts in Long Scripts\n\n\n\nThese weird special lines can make finding merge conflicts in longs scripts much easier! Simply use your IDE’s search function to look for four &lt;&lt;&lt;&lt; next to one another as it is unlikely such a line would normally be included in your code.\n\n\nOnce Git has combined the two versions of the file, it is up to us to read through the script and edit it so that it looks right to us. At a minimum, this involves deleting the weird lines (in the screen capture below they are liens 1, 5, and 8) but in more difficult cases you may need to consider which version of the line is the one you want to retain.\nPositron also helpfully provides buttons over each merge that allow us to quickly choose which version of the code we want but we could also edit the script manually.\nIn this case, we can retain both lines of code without damaging either so let’s just delete the special character lines.\n\n\n\nOnce you are confident you’ve fixed the conflict, commit the changes you made to resolve the conflict. This is done in the same way that you’d normally make a commit. Note you will likely want to replace the default merge conflict commit message with something that is more human-readable.\n\n\n\nBefore you sync, take note that the “Sync Changes” button is telling you that you have two changes to contribute. This is because both your original commit and your second commit (fixing the conflict) have yet to be pushed back up to GitHub–your first push failed because of the merge conflict. Once you’ve noted that, sync your changes.\n\n\n\nYour Positron should now look how it did before you got the conflict and you can continue working normally–hopefully having learned a lesson in proactive communication with your collaborators.",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "conflicts.html#avoiding-conflicts",
    "href": "conflicts.html#avoiding-conflicts",
    "title": "Conflicts",
    "section": "Avoiding Conflicts",
    "text": "Avoiding Conflicts\nMerge conflicts aren’t exactly fun, so here are some tips to avoid them:\n\nCommunicate with your team members often to avoid working on the same files at the same time! Let each other know who is working on what\nPull early and often\nPush your commits frequently (always pulling before pushing!)",
    "crumbs": [
      "Advanced Topics",
      "Conflicts"
    ]
  },
  {
    "objectID": "git-background.html",
    "href": "git-background.html",
    "title": "Git Background",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “version control”\nDescribe the difference between Git and GitHub",
    "crumbs": [
      "General Background",
      "Git Background"
    ]
  },
  {
    "objectID": "git-background.html#module-learning-objectives",
    "href": "git-background.html#module-learning-objectives",
    "title": "Git Background",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine “version control”\nDescribe the difference between Git and GitHub",
    "crumbs": [
      "General Background",
      "Git Background"
    ]
  },
  {
    "objectID": "git-background.html#version-control-background",
    "href": "git-background.html#version-control-background",
    "title": "Git Background",
    "section": "Version Control Background",
    "text": "Version Control Background\nVersion control systems (including Git) are built to preserve the iterative versions that we create on the way to a final product. For instance, when writing a scientific manuscript we might have several discrete stages (e.g., separate drafts after successive rounds of feedback from collaborators) as well as the sort of small-scale changes we don’t necessarily preserve in separate files (e.g., workshopping a particular sentence for rhetorical flow).\nVersion control systems provide a framework for preserving these changes without cluttering your computer with all of the files that precede the final version.",
    "crumbs": [
      "General Background",
      "Git Background"
    ]
  },
  {
    "objectID": "git-background.html#git-specific-background",
    "href": "git-background.html#git-specific-background",
    "title": "Git Background",
    "section": "Git-Specific Background",
    "text": "Git-Specific Background\nGit can be enabled on a specific folder/directory on your file system to version files within that directory (including sub-directories). In Git (and other version control systems) terms, this “tracked folder” is called a repository (which formally is a specific data structure storing versioning information).\nAlthough there many ways to start a new repository, GitHub (or any other cloud solutions, such as GitLab) provide among the most convenient way of starting a repository.\nLet’s distinguish between Git and GitHub:\n\nGit: version control software used to track files in a folder (a repository)\n\nGit creates the versioned history of a repository\n\nGitHub: website that allows users to store their Git repositories and share them with others (i.e. a graphical user interface or “GUI”)\n\nGitHub is a company that hosts Git repositories online and provides several collaboration features. GitHub fosters a great user community and has built a nice web interface to Git, also adding great visualization/rendering capacities of your data.\n\nGitHub.com: github.com\nA user account: github.com/angelchen7\nAn organization account: github.com/lter",
    "crumbs": [
      "General Background",
      "Git Background"
    ]
  },
  {
    "objectID": "ide.html",
    "href": "ide.html",
    "title": "Using GitHub with an IDE",
    "section": "",
    "text": "WarningIMPORTANT: Do the Preparation Steps!!!\n\n\n\nYou can only successfully complete this module if you have done the “Workshop Preparation” steps for RStudio or Positron in this website’s homepage! It doesn’t matter whether you choose RStudio or Positron but you must have done all of the steps for one of those programs or you will encounter errors later. Later workshop modules also require this preparation but this is the most frequently-used module and thus particularly warrants this reminder.",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#module-learning-objectives",
    "href": "ide.html#module-learning-objectives",
    "title": "Using GitHub with an IDE",
    "section": "Module Learning Objectives",
    "text": "Module Learning Objectives\nBy the end of this module, you will be able to:\n\nDescribe the IDE-to-GitHub order of operations\nDefine fundamental Git vocabulary\nCreate a local version-controlled repository that is connected to GitHub",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#overview-of-git-workflow",
    "href": "ide.html#overview-of-git-workflow",
    "title": "Using GitHub with an IDE",
    "section": "Overview of Git Workflow",
    "text": "Overview of Git Workflow\nBefore we get into using Git and GitHub through an IDE (Integrated Development Environment), it will be helpful to review the major steps of including version control as you work on code. Also, note that “IDE” is the technical term for a piece of software that is used to create software; RStudio, Visual Studio Code, and Positron are all examples of IDEs with which you may already be familiar.\nBeginning on your local computer, you make changes to a file in a folder that you have previously marked for version control tracking (i.e., a working directory). Once those changes are made you can stage changes within your local computer. After staging, it is best to retrieve the latest file versions from the cloud. You likely will already be up-to-date but this preemptive step can save you a lot of heartache down the line. Once you’ve confirmed that you have the latest file versions, you can shift the revised file(s) to the cloud where any GitHub users with access to your project can access the most recent file and look at the history of all previous changes.\n\n\n\n\n\n\nNote“Pull & Push” vs. “Sync”\n\n\n\nSome IDEs (e.g., Positron, VS Code) combine a pull and a push into a single operation called a “sync”. These IDEs also support pulling and pushing separately so you may want to do those operations separately until you are completely comfortable with the necessary order of operations.",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#git-vocabulary",
    "href": "ide.html#git-vocabulary",
    "title": "Using GitHub with an IDE",
    "section": "Git Vocabulary",
    "text": "Git Vocabulary\nFinally, it will be helpful to introduce four key pieces of vocabulary before we dive into the interactive component of this workshop.\n\nClone = copy the entire contents of a GitHub repository to your local computer (done once per computer)\nCommit = move a changed local file to your local staging area (step 2 of the above diagram)\nPull = get file(s) from the cloud to your local computer – opposite of a “push” (step 3)\nPush = move file(s) to the cloud from your local computer – opposite of a “pull” (step 4)",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#cloning-a-repository",
    "href": "ide.html#cloning-a-repository",
    "title": "Using GitHub with an IDE",
    "section": "Cloning a Repository",
    "text": "Cloning a Repository\nRegardless of which IDE you are using, the first step of using using Git with that IDE is to clone the repository from GitHub. To clone a repository, follow the steps under the relevant tab for your IDE.\n\nIn RStudioIn Positron\n\n\nNavigate to the GitHub homepage of the repository that you’d like to clone.\n\n\n\nOnce you are there, click the “Code” button then, in the resulting dropdown menu, copy the link under the “HTTPS” tab.\n\n\n\nNow, switch over to RStudio. In the top right corner of RStudio, click the dropdown menu with a glass box containing a capital “R”. This button may have the name of the current RStudio project (i.e., the working directory) if you have previously used RStudio but may otherwise be just the glass box icon with “Project: (None)”.\n\n\n\nOnce you have clicked that button in order to open its dropdown menu, click “New Project…”\n\n\n\nIn the resulting pop-up window, select “Version Control”.\n\n\n\nIn the next page of the pop-up menu, select “Git”.\n\n\n\nIn the final page of the pop-up window, you can now specify details about the repository that you want to clone. Most critically, paste in the link you copied from the “Code” dropdown menu in GitHub in the “Repository URL” field. You can also choose the local name of the folder for this clone and where on your computer you want to create the clone; the example below just clones into the “Documents” folder but you may want to place the clone elsewhere depending on how you organize your files.\nOnce you have pasted in the relevant link and are happy with the local name and where the clone will be made, click “Create Project”.\n\n\n\nNow we have finished cloning the repository via RStudio! Notice that we are now working in the “git-practice_rstudio” project (see the name next to project name in the top right corner) and that a number of files are visible in the “Files” pane in the top right quadrant (including the “README.md” and “.gitignore” files found in our GitHub repository).\n\n\n\n\n\nNavigate to the GitHub homepage of the repository that you’d like to clone. Once you are there, simply copy the URL in your browser’s navbar (should start with “github.com/…”).\n\n\n\nNow, switch over to Positron. In the top right corner, click the dropdown menu with a folder icon. This button may have the name of the folder Positron is currently focused on (i.e., the working directory) if you have previously used Positron but may otherwise be just a folder icon without text.\n\n\n\nIn the resulting dropdown menu, select “New Folder from Git…”.\n\n\n\nThis will open a pop-up window where you can paste in the GitHub repository link that you copied earlier. You can also choose where on your computer you want to create the clone; the example below just clones into the “Documents” folder but you may want to place the clone elsewhere depending on how you organize your files.\nOnce you have pasted in the repository link and chosen where to download its files, click “OK”.\n\n\n\nNow we have finished cloning the repository via Positron! Notice that we are now working in the “git-practice_positron” folder (see the name next to folder icon in the top right corner) and that a number of files are visible in the files pane in the left sidebar (including the “README.md” and “.gitignore” files found in our GitHub repository).",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#workflow-refresher",
    "href": "ide.html#workflow-refresher",
    "title": "Using GitHub with an IDE",
    "section": "Workflow Refresher",
    "text": "Workflow Refresher\nThe typical workflow with Git goes like this:\nStep 1: You modify files in your working directory and save them as usual.\nStep 2: You stage files to mark your intention to “commit” them and then commit that version of those files. Committing files permanently stores them as snapshots to your Git directory.\n\nRStudio CommitsPositron Commits\n\n\nIn RStudio, staging is done by checking the box next to a file in the “Git” tab\n\n\nIn Positron, staging is done by clicking the plus sign next to a file in the “Source Control” menu in the left sidebar\n\n\n\nStep 3: You pull the most recent changes to make sure you’ve been editing the latest versions.\nStep 4: You push your the version of your files that you committed to GitHub.\nHere is the infographic from the start of this chapter again, which shows the same workflow:",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#stage-versus-commit",
    "href": "ide.html#stage-versus-commit",
    "title": "Using GitHub with an IDE",
    "section": "Stage versus Commit",
    "text": "Stage versus Commit\nThe functional difference between “staging” a file and “committing” one can be a little tough to grasp at first so let’s explore that briefly here. We can make an analogy with taking a family picture, where each family member would represent a file.\n\nStaging files is like deciding which family member(s) are going to be in your next picture\nCommitting is like taking the picture\n\nThis 2-step process enables you to flexibly group files into a specific commit. Those groupings can be helpful to you later if you’re trying to find what you changed for a specific task (because those changes likely are all in the same commit).",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#creating-a-new-file",
    "href": "ide.html#creating-a-new-file",
    "title": "Using GitHub with an IDE",
    "section": "Creating a New File",
    "text": "Creating a New File\nLet’s try out a simple Git workflow by first creating a new file. This is Step 1 of the process. To begin, open your IDE and get to the clone you just made in the previous steps. Once you are there, make a new R script and name it after yourself (e.g., lyon-script.r).\n\nIn RStudioIn Positron\n\n\nOnce you have a new file in your cloned folder (i.e., the folder on your computer that you’ve told Git to track). If you click the “Git” tab–usually found in the top right quadrant of RStudio-you should see two files listed: your “.Rproj” file and the new script you created.\nBoth files have double yellow ? icons indicating that they are in the tracked folder but are not currently tracked themselves. Let’s get ready to commit our new script by clicking either of the two left-most buttons in the Git tab (they both open the same window).\nThe reason that neither the “README.md” nor the “.gitignore” appear in this tab is that the Git tab will only show files whose status has changed since the last commit. Those two files are the same as when we cloned them so they won’t appear here.\n\n\n\nNote that there are other color-coded icons that can appear next to files in your working directory. These icons are shorthand for the Git status for any file whose status has changed since the last commit that you made. See below for a set of some of the more common icons along with their meaning.\n\n\n\n\nCommit the File\nBy clicking one of the buttons in the previous step, we’ve opened the window where we can commit our new script. To actually make the commit, we need to do three things:\n\n“Stage” the new file by checking the box next to it\n\nNote that when you do this, the two yellow ? will become a green A to indicate we’re adding the file to Git tracking\n\nWrite a commit message about what this commit entails\n\nThink about what information will be useful to ‘future you’ or your collaborators 6+ months from now\n\nClick the “Commit” button\n\n\n\n\nAfter you click the “Commit” button, you should get a message that looks something like the following screen shot. You can now close both this new message as well as the pop-up window and return to ‘normal’ RStudio.\n\n\n\nIf the above steps went well, you should see something like the following image. The important bits are twofold: (1) your script is no longer listed in the Git tab and (2) there is a message saying “Your branch is ahead of ‘origin/main’ by 1 commit”.\n\n\n\nWe can leave aside what “origin/main” specifically means for now but we did just make one commit so we can surmise that our local clone should have one more commit than what GitHub knows about (at this point).\n\n\nGet the Latest Updates\nBefore we can send our one commit up to GitHub, let’s make sure that we have all the changes that GitHub has by “pulling” the repository. To do this, click the blue downward-facing arrow button in the Git pane. Because we are working alone in this tutorial, there should be no changes so you should get the following message.\n\n\n\nNote that when you are collaborating with a large team, you will want to pull early and often so that you avoid the risk of working on an outdated version of a file. You may also want to pull before making a commit to further reduce the risk of errors.\n\n\nSend Your Commit to GitHub\nNow that we have made our commit and confirmed there are no changes in the GitHub repository that we don’t already have, we can “push” our changes back to GitHub. To do this, click the green upward-facing arrow button in the Git pane. You should get a message that is something like the following image.\n\n\n\nIf we return to the GitHub home page for our repository, we can now see our script is there and the commit message is the same as the message we typed in RStudio!\n\n\n\n\n\n\n\n\n\nNoteIf RStudio ever asks for a “password”…\n\n\n\nIf your personal access token (PAT) was not set up correctly with RStudio or if it expired, then RStudio will ask for your GitHub username and password in a pop-up when you try to push. Please be aware that when they ask for a “password”, they actually meant your token! Enter your token in the field and you should be able to push now. Make sure to run gitcreds::gitcreds_set() to set a valid token afterwards so you don’t have to enter it manually every time!\n\n\n\n\n\nOnce you have a new file in your cloned folder (i.e., the folder on your computer that you’ve told Git to track). Positron should display the Git status of the file next to the file’s name. In this case, because this a new file that isn’t yet tracked by Git, there should be a U indicating that it is “untracked.”\nLet’s get ready to commit our new script by clicking the “Source Control” piece of the left sidebar. That button should have a red “1” next ot it and its icon looks like this: \n\n\n\nOnce you are in the source control menu, you should see a list of the files with changes–currently only the new file that you just made.\n\n\n\nThe reason that neither the “README.md” nor the “.gitignore” appear in this menu is that the source control menu will only show files whose status has changed since the last commit. Those two files are the same as when we cloned them so they won’t appear here.\n\nCommit the File\nWe are now in the right place for us to commit our new script. To actually make the commit, we need to do three things:\n\n“Stage” the new file by click the plus sign next to it\n\nNote that when you do this, the U will become an A to indicate we’re adding the file to Git tracking\n\nWrite a commit message about what this commit entails\n\nThink about what information will be useful to ‘future you’ or your collaborators 6+ months from now\n\nClick the “Commit” button\n\n\n\n\nIf the above steps went well, you should see something like the following image. The important bits are twofold: (1) your script is no longer listed and (2) in the menu at the bottom of this sidebar the label with a cloud (titled “origin/main”) is beneath a label with the commit message that you just wrote.\nAdditionally, the “Commit” button should now be a “Sync Changes” button.\n\n\n\nWe can leave aside what “origin/main” specifically means for now but we did just make one commit so we can surmise that our local clone should have one more commit than what GitHub knows about (at this point).\n\n\nOther Git Actions\nIf you’ve previously used other IDEs, you may notice that Positron’s single centralized button (while making normal use dramatically simpler) does hide other Git actions you may want to do. For example, if you edit several files, commit the changes to one, and want to sync just that commit, the “Sync” button is absent because the “Commit” button takes precedence.\nIn order to see a full list of Git options, hover your mouse over the “changes” panel (just above the commit message field) and click the ellipses (...) that will appear when you are hovering there.\nYou should now see a full list of the normal suite of Git actions that you can perform through Positron. If you want to sync, see the first option under the heading “Pull, Push” (about two thirds of the way down the dropdown menu).\n\n\n\nFor our purposes here, the sync button is sufficient but you may want these other tools in the future.\n\n\nSyncing the Clone and GitHub\nOnce you’re ready to sync changes between your clone and the GitHub repository it is in contact with, you can click the “Sync Changes” button.\nIf this is the first time you are doing this, you may get a warning like the following screenshot. If you get that message, click “OK, Don’t Show Again”.\n\n\n\nYou will know that the sync worked because the “Sync Changes” button will revert to a “Commit” button. In our case, because that was the only file with any changes, it means there is nothing in that list and the “Commit” button is grayed out and inactive Additionally, the purple and blue labels in the bottom of the left sidebar will both be on the topmost commit message.\n\n\n\nIf we return to the GitHub home page for our repository, we can now see our script is there and the commit message is the same as the message we typed in Positron!",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "ide.html#rinse-and-repeat",
    "href": "ide.html#rinse-and-repeat",
    "title": "Using GitHub with an IDE",
    "section": "Rinse and Repeat",
    "text": "Rinse and Repeat\nGreat! Now that your script has been added to the group repository, you should try to repeat the same workflow over again just to get a feel for how it works. Go back to your IDE and edit your own script. Save those edits, add your edited file to the staging area, write a commit message, then commit your changes. After committing, make sure to pull first then push after! When you pull, you might notice that scripts from your group members/collaborators will show up in your working directory.\nMake sure to work on your own script. If you and another group member work on the same script at the same time, this may lead to merge conflicts with Git. If two people were to work on the same script, they may be making different edits on the same lines, and Git would not know which edits to keep. To avoid merge conflicts, be mindful of what files you are working on and always communicate this to your group members!",
    "crumbs": [
      "Using GitHub...",
      "With an IDE"
    ]
  },
  {
    "objectID": "issues.html",
    "href": "issues.html",
    "title": "GitHub Issues",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine an issue in the context of GitHub\nCreate a new issue in an existing repository\nExplain considerations for creating a useful, appropriately-scoped issue",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#module-learning-objectives",
    "href": "issues.html#module-learning-objectives",
    "title": "GitHub Issues",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDefine an issue in the context of GitHub\nCreate a new issue in an existing repository\nExplain considerations for creating a useful, appropriately-scoped issue",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#what-is-an-issue",
    "href": "issues.html#what-is-an-issue",
    "title": "GitHub Issues",
    "section": "What is an Issue?",
    "text": "What is an Issue?\nIssues are a convenient way of identifying and delegating tasks within a repository as well as documenting progress over time. They can also be used as a digital ‘lab notebook’ for personal use to brainstorm on a novel topic or preserve important links or supplementary material for easy distribution across a whole team.\nImportantly, while issues can definitely be helpful they are not required to successfully use GitHub for collaborating as a team. Issues absolutely have the potential to facilitate division of labor within a team though and are thus worth covering in this training.\nAn additional function that may be outside of the scope of what you need to use within your team is that it allows non-members to flag issues that they’ve had with code written by your team or request additional functionality that doesn’t yet exist in your framework. Depending on your use of packages in R you may have already opened an issue on an existing R package to do just that!\nTo see a more complete example of how issues can be used we can examine the open issues of an established R package.\n\nIssues Example with the googledrive Package\nBelow is the GitHub landing page for the googldrive package and you can see that next to the underlined “Code” tab is an “Issues” tab with a gray circle with the number 22 in it. This number notifies us that as of this screen capture, there were twenty two open issues on this package’s GitHub repository. Note that your GitHub interface may be white but it will not change the position of buttons or tabs.\n\n\n\nIf you click over to the issues tab you will see the titles of all current “open” (i.e., ongoing) issues on the repository. Each issue has a title and beneath that a unique number following a # as well as how long ago the issue was opened and the GitHub username of the person who opened the issue. On the right side of each issue’s thumbnail you can see the number of comments added to it.\n\n\n\nComments can be used to have a full dialogue among different users – potentially both in and outside of the team responsible for managing the code! The conversational aspect of issues can make them functionally similar to an email thread or messaging app chain. This communication can help keep the solutions to tasks well-documented while ensuring that every member of your group can have their voice heard.",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#creating-your-first-issue",
    "href": "issues.html#creating-your-first-issue",
    "title": "GitHub Issues",
    "section": "Creating your First Issue",
    "text": "Creating your First Issue\nWhen you first visit the Issues tab of your repository it won’t include any open issues and will look like this.\n\n\n\nTo create an issue, click the green button and a new page will open that looks like the below.\n\n\n\nIn this page you can create a brief title (these are better if they are concise while still trying to convey the broader context for the task identified by the issue) and add a longer comment into the body of the issue. That longer comment can be as simple as a few bullet points of what the problem is or as complex as a markdown-formatted hyperlink-supported thesis on the task at hand.\nWhile issue comments are completely free for you to use as you see fit, it is important to remember that your most frequent collaborator is yourself in the future so a future version of yourself will absolutely thank you for including extra information when you first open an issue. In a team setting like this one, extra detail can also really help when the person opening the issue is not the person responsible for editing the code to address it.\nIn addition to the title and main body of the issue you can also see a sidebar on the right containing other options for adding detail to an issue. In particular, the “Assignees” and “Labels” sections can be useful in delegating a task to a specific person or naming the category that this task falls under respectively.\nReturning to our googledrive example for a moment, you can see that the package maintainers use multiple labels on some issues to help communicate across their team what processes are affected by or relevant to each particular issue.\n\n\n\nWhen you are creating your first issue however you won’t have any of those customized labels. However, GitHub does offer some pre-built template labels that may suit your needs and makes adding your own customized labels very approachable.\nTo see the current label options, click the “Labels” text or the gear to its right and either scroll and click the desired label(s) from the list or scroll to the bottom and click “Edit labels” to create new labels or modify the template labels.\n\n\n\n\n\n\n\n\n\nNotePractice - Labels\n\n\n\nWhat are some labels that might be useful for your project to divide up issues? Can labels divide tasks related to analysis versus visualization of data? Or use them to further subdivide within those categories?",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#opening-an-issue",
    "href": "issues.html#opening-an-issue",
    "title": "GitHub Issues",
    "section": "Opening an Issue",
    "text": "Opening an Issue\nOnce you’ve filled out the title and comment of the issue the green “Submit new issue” button will become clickable and you can click it to open your issue. You can either add labels or assign users to the issue during the initial opening phase or after the fact.\nIssues are automatically viewed as a sequential series of events from the first comment so all future additions to the issue will be added beneath that first comment that defines the title of the issue.\nAt the bottom of the issue there will be an open text box that you can add to with whatever information you feel is valuable in the context of this task. We will talk about closing issues in a moment but even when issues are closed they are always accessible so all documentation within an issue can be used later and is well worth any energy investment you can make.\nThere is also not a time limit on issue comments so issues can remain open and active for as long as you find them useful.",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#appropriate-issue-scope",
    "href": "issues.html#appropriate-issue-scope",
    "title": "GitHub Issues",
    "section": "Appropriate Issue Scope",
    "text": "Appropriate Issue Scope\nAs a brief aside from the nuts and bolts of how to create and manage an issue, it is important to discuss appropriate issue scope.\nEssentially, an issue should- as much as possible-directly correspond to either a single task or a single conversation. It is not always possible to predict how projects can evolve at the outset so you may find issues spanning multiple tasks despite your best efforts but as much as you can plan to keep a 1-to-1 ratio of tasks to issues you will find delegation and tracking of task completion that much easier.\nPersonally, I am a longtime believer in S.M.A.R.T. goals (i.e., goals that are Specific, Measurable, Attainable, Relevant, and Time-specific), but there are many established ways of partitioning a larger project to achievable sub-tasks and you should use whichever is most intuitive to you.\nIf issues seem like something that your group is broadly interested in it may be worthwhile to have a conversation about some general ‘rules of thumb’ for the scope of tasks identified by issues.\n\n\n\n\n\n\nNotePractice - Create an Issue\n\n\n\nNow that we’ve covered what issues are and how to open them, let’s take a minute and create some issues on your repository! On your GitHub repository, click over to the Issues tab and create a new issue. This can be either a placeholder just to have experience creating an issue or a real task that you think the team will have to deal with in the future. We are here if you need clarification!",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "issues.html#closing-an-issue",
    "href": "issues.html#closing-an-issue",
    "title": "GitHub Issues",
    "section": "Closing an Issue",
    "text": "Closing an Issue\nSo, let’s imagine that you have worked through whatever task you identified and are ready to be done with this issue and move on to the next task.\nIf you scroll to the bottom of that issue (where the adding comment textbox is) you will see a purple button titled “Close issue”.\n\n\n\nAfter clicking that button a purple check mark will appear on the bottom of the issue’s timeline that identifies the issue as closed and credits the user who closed it.\n\n\n\nWhen you return to your issue list you will see that issue is now absent from the list. However, next to the “[number] Open” button you can see a check mark with the number of closed issues.\n\n\n\nClicking that “Closed” button will access all past issues that are now closed.\n\n\n\nSo, even if an issue was closed in the distant past of your repository on GitHub, you can still easily access and view all of its contents.\nThis greatly facilitates the use of issues in tracking problem solving, brainstorm sessions, and supporting documents. The Scientific Computing Support team at NCEAS uses issues as personal lab notebooks (in addition to the aforementioned uses) to ensure that individual process is well documented while still being easily accessible by other team members.\nAs pointed out earlier though, issues are fundamentally optional to the use of GitHub and may not be needed by your team right now. However, we’d encourage you to try using them in case they do prove helpful to your team!",
    "crumbs": [
      "Project Management",
      "GitHub Issues"
    ]
  },
  {
    "objectID": "motivations.html",
    "href": "motivations.html",
    "title": "Workflows",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe various coding workflows\nParaphrase how version control workflows facilitate collaboration on code products",
    "crumbs": [
      "General Background",
      "Workflows"
    ]
  },
  {
    "objectID": "motivations.html#module-learning-objectives",
    "href": "motivations.html#module-learning-objectives",
    "title": "Workflows",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe various coding workflows\nParaphrase how version control workflows facilitate collaboration on code products",
    "crumbs": [
      "General Background",
      "Workflows"
    ]
  },
  {
    "objectID": "motivations.html#workflow-options",
    "href": "motivations.html#workflow-options",
    "title": "Workflows",
    "section": "Workflow Options",
    "text": "Workflow Options\nIf you are working on any file that is the product of iterative edits, you have had to develop a workflow to approach that task. This could be a scientific paper, analytic code, or a presentation. There are many possible ways you could approach this task leveraging any number of software and hardware options but before we get into our discussion today about collaborative research using GitHub we would like to–briefly–outline some of the typical forms these workflows can take and how they fit into a broader framework of individual and synthesis science.\n\nIndividual Workflow\nAt its simplest, you could be storing your data and code on your local machine and doing the entirety of your work alone. When working on your code you would iteratively edit and save the same code file and you would have a static folder (or folders) for data that you added to as you collected and entered or downloaded additional data.\nThere are variants of this where you may be archiving everything on your hard drive (e.g., Time Machine on Mac OS, etc.) and you may be using a “save as” feature to preserve some iterations of your code. You may also perform this same operation within a cloud-based storage system (e.g., Box, Dropbox, Google Drive, etc.) so that some versions of both code and data are preserved based on time stamps.\nThis approach has the advantage of relatively few moving parts but such editing of your code loses all previous versions that aren’t explicitly preserved (as well as a record of the changes).\nAnother limitation of this approach is that to work collaboratively, everything would need to be manually shared with your collaborator(s) which introduces a significant risk that someone in the research team would accidentally use the “wrong” version of either the code or the data.\n\n\n\n\n\nData Lifecycle Considerations\nThe above approach works when doing largely individual research, but what about at other stages in the typical lifecycle of data? Said lifecycle is displayed below where data is acquired via planning and collection, data are assessed and preserved, and finally, data are synthesized and used to inform future plans.\nIndividual workflows performed by a small research team can be well-served by the relatively bare-bones workflow illustrated above but such projects often emphasize data acquisition and preservation over synthesis and thus are not as limited by a need for real-time collaboration on coding scripts across a team. Individual projects certainly do data synthesis, they just by their nature have to emphasize data collection at least as much as the synthetic components of research.\nHowever, for larger teams–especially those that span disciplinary boundaries or have ongoing data collection protocols (e.g., research coordination networks, working groups, etc.)–the synthesis part of the data lifecycle often becomes progressively more important. This importance is tightly linked to a need for collaboration among team members on wrangling, analysis, and visualization scripts that in individual workflows can be managed by a single team member but cannot be in synthesis projects.\nCollaboration on coding can be accomplished by manually sharing code and data among group members but there are programs and websites that are specifically dedicated to meeting the need for collaboration. One example is “version control” systems (e.g., GitHub, SVN, etc.) that provide a framework for reproducible group work.\n\n\n\n\n\nSynthesis Workflow\nVersion control systems preserve the iterative changes you and your team make to code and allow for informative titles and messages to be attached to these snapshots. This offers a clear advantage over ambiguous time-stamped versions preserved by cloud storage systems as it facilitates re-visiting code long after or by new team members who were not present for the initial writing. This approach is what we will be covering in greater depth in a few moments but the broad strokes are that you would preserve the history of your work and ensure that everyone uses the “right” version of the code.\nHowever, despite its advantages for collaborative coding, version control is not meant for preserving data so you would need to share data with your collaborators either via email or by storing data in the cloud and sharing links with team members. Depending upon how you implement either route for sharing data (email vs. cloud) your group is still at risk for group members using different versions of the data–especially if your group is involved in ongoing data collection.\nFurther, an inconvenience associated with this workflow is that each group member will store their copy of the data in a different network of nested folders on their local machine. This means that all references in the code to the path of the data (e.g., “home/users/me/project/data/…”) will differ, so running a collaboratively-developed piece of code would require careful specification to avoid getting a ‘this folder does not exist’ error. This is absolutely surmountable but can be a source of frustration over longer project timelines.\n\n\n\n\n\nSynthesis Workflow on NCEAS’ Server\nFinally (for our purposes), you could build NCEAS’ server into your workflow to not only collaborate with colleagues on code but also centralize your data storage!\nThis method has all of the coding advantages of a workflow with version control (see above) in that it still facilitates reproducibility, transparency, and collaborative work. However, it also offers a secure location for all of your data to be stored that is accessible to all members on the same folder path.\nThis means that even though each group member could code separately in their own ‘home’ folder on the server (and send those changes back and forth with GitHub) all code could reference the same data location in the ‘shares’ folder on the server. This guarantees not only that all team members are using the same version of the data but that they are using the same exact data file.\nData can be moved from a specific computer onto the server by using any “File Transfer Protocol” (FTP) software (or “SSH FTP” a.k.a. SFTP). These programs function very much like the file manager on your computer (e.g., Finder on Mac) and allow simple dragging-and-dropping of files between your computer and the server. NCEAS has a tutorial on how to go about setting up an FTP or SFTP program on your computer that we are also happy to go over in greater depth as needed!\nAdding the server to your team’s workflow also allows you to work on code both on your folder in the server and on your personal computer as needed. This means that using the server for some of your coding needs does not mean that you are limited to solely using the server ad infinitum thereafter.\nAn ancillary benefit of this approach is the dramatic improvement in computational power when using the server (as compared to even a fast personal computer)\n\n\n\n\n\nSummary\nWhile each approach offers its own strengths and weaknesses, in our experience many scientists avoid the latter two options due to knowledge barriers about how to get set up in these programs and websites, much less how to actually navigate those systems once set up!\nToday, we will strive to cover the fundamentals of using a version control system in your workflow (Option 2) and–for some groups, depending on interest–how to extend that workflow further and leverage NCEAS’ server to share data and work on code.\nPlease don’t hesitate to ask questions and remember that this link is a resource that you should feel free to refer back to if you ever need a refresher or wish to teach peers! There are supplementary appendices as well which we do not anticipate being able to get to today but we do think are likely to be valuable to you as your confidence with these systems grows.",
    "crumbs": [
      "General Background",
      "Workflows"
    ]
  },
  {
    "objectID": "prep-steps/celebrate.html",
    "href": "prep-steps/celebrate.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "After following all the previous preparation steps, your setup should now be complete."
  },
  {
    "objectID": "prep-steps/connect_git-github_positron.html",
    "href": "prep-steps/connect_git-github_positron.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "The last step to take before you’re all set for the workshop is to get these components talking to one another! One reason to use Positron instead of RStudio is because of how much simpler this step is for Positron. Instead of needing to write code, we can do a little authentication dance with buttons in the browser and afterwards, everything will ‘just work.’\nTo begin, open Positron. You should have a screen that looks something like the below screen capture. Note that you might be in “light mode” depending on your computer settings but that should not affect which buttons to click or where they can be found.\n\n\n\nFrom there, go to the left sidebar and click the branch icon (  ). It should be the third option from the top. Once you are there, click “Clone Repository”.\n\n\n\nThis should automatically open the search bar in the top middle of Positron and present you with a single option titled “Clone from GitHub”. Click that option.\n\n\n\nOnce you’ve clicked that option, you should be presented with the following pop up where Positron is telling you that Positron’s GitHub extension wants to talk to the online version of GitHub. Click “Allow”.\n\n\n\nPositron will now allow provide you with a code of random letters/numbers that you’ll need to share with GitHub. Helpfully, a new pop-up will appear where one of the options is “Copy & Continue to Github”; click that option.\n\n\n\nOnce you click “Copy & Continue to Github” button, you should automatically be sent to your default web browser application and be prompted to choose which GitHub account to use. Most users will have only one option so go ahead and click “Continue” next to that profile.\n\n\n\nYou’ll next need to put in the code that you got from Positron. You should be able to simply paste it in because you just copied it! After you’ve entered the code, click “Continue”.\n\n\n\nGitHub will now provide you with a list of the permissions that Positron is asking for and ask you to approve them. These permissions are required for you to work with Positron so feel free to read through them but ultimately you must scroll down and click “Authorize”.\nIf you are a member of any GitHub organizations, they will be listed below the list of requested permissions but you should just ignore those and scroll past them.\n\n \n\n\n\n\n\n\n\nNoteGitHub Login Prompt\n\n\n\nIf you have not recently logged in to GitHub, you will be sent to the standard GitHub login page. If you are sent there, log in as normal (i.e., either by using your username/password or with the 2FA option provided by the GitHub Mobile app).\n\n\nOnce you’ve worked through the above step, you should get a confirmation page from GitHub that looks like the following screen capture.\n\n\n\nYou will know that you’ve followed these steps correctly if, when you return to Positron, the search bar in the top middle (that said “Clone from GitHub” before) now has a list of repositories to which you have access."
  },
  {
    "objectID": "prep-steps/create_github-acct.html",
    "href": "prep-steps/create_github-acct.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "Start by creating an account on GitHub. GitHub is how you’ll be able to collaborate with others in a way that tracks changes over time while facilitating a range of project management tools.\nDr. Jennifer Bryan has some nice guidelines for picking a good username so choose carefully when you make your profile. We also recommend adding a picture of yourself so that group members can more confidently identify one another on GitHub."
  },
  {
    "objectID": "prep-steps/install_positron.html",
    "href": "prep-steps/install_positron.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "Once you have R (ver. ≥4.0), install Positron. If you already have Positron installed, you may want to make sure that you’re using a recent version to take advantage of the features available in the most recent version."
  },
  {
    "objectID": "prep-steps/install_rstudio.html",
    "href": "prep-steps/install_rstudio.html",
    "title": "SciComp Workshop - Collaborative Coding with GitHub",
    "section": "",
    "text": "Once you have R (ver. ≥4.0), install RStudio. If you already have RStudio installed, you may want to make sure that you’re using a recent version to take advantage of some quality of life improvements that are broadly useful."
  },
  {
    "objectID": "readmes.html",
    "href": "readmes.html",
    "title": "Informative READMEs",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the value of an informative README\nRefine a README on an existing repository",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  },
  {
    "objectID": "readmes.html#module-learning-objectives",
    "href": "readmes.html#module-learning-objectives",
    "title": "Informative READMEs",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the value of an informative README\nRefine a README on an existing repository",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  },
  {
    "objectID": "readmes.html#what-is-a-readme",
    "href": "readmes.html#what-is-a-readme",
    "title": "Informative READMEs",
    "section": "What is a README?",
    "text": "What is a README?\nA README does exactly what its name suggests: it contains a summary of all of the information needed to navigate a given folder’s contents. However, you are responsible for creating a README and adding content to it so its value is somewhat dependent upon the time you are willing and able to spend on fleshing it out.\nIn GitHub, READMEs can be particularly useful because they form a landing page at the bottom of your repository’s GitHub page that can be a great way of introducing new people to your project or refreshing ‘future you’ on how you stored things for a given project.\nA README is almost always either a Markdown file (ending in “.md”) or an R markdown file (“.Rmd”). The default for a GitHub repository is “.md” but if you want your README to run R code (e.g., to create graphs, run analysis, etc.) you can create a .Rmd one that can support R code chunks.",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  },
  {
    "objectID": "readmes.html#example-readme",
    "href": "readmes.html#example-readme",
    "title": "Informative READMEs",
    "section": "Example README",
    "text": "Example README\n\nLet’s check out the README for the R package lterpalettefinder as one example of an informative README. This R package was developed by the LTER Network Office to share official palettes derived from photos taken at LTER sites and evolved to include a suite of R functions that allow color palettes to be extracted from any user-supplied photo.\nThe README for lterpalettefinder is crucial because it provides the following information:\n\nBrief description of the purpose / utility of the package\nInstructions on how to install the “development version” of the package\n\nThis is useful because the version of a package that is on CRAN (and can be installed with install.packages()) is often less up-to-date than the version that is available on GitHub\n\nList of current functions and what they do\nHex logo of the package\n\nVisitors to the README see the following:\n\n\n\nThis README contains a bunch of “bonus” information including nice aesthetic touches and various “badges” denoting timing of last commit and that the package has no errors among other things.\nThe “README.Rmd” file in the GitHub repository can be found at the bottom of the repository list of files (which works out to be just above the rendered README landing page!).\n\n\n\nIf you click that file, you can view the “raw” file which is written in “markdown syntax”. Markdown syntax is a simplified (relatively) way of formatting text that provides coarse control without getting bogged down in potentially unnecessary levels of detail. Markdown syntax is discussed extensively elsewhere and your README can be very valuable with just plain text in a .md file so we will avoid discussing it in detail here.\nThe main take away here is that “under the hood”, this package’s README landing page is generated from the formatting specified in this “raw” file. Flip back and forth between the raw view and the displayed README and see if you can catch how various text formatting was accomplished!",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  },
  {
    "objectID": "readmes.html#writing-a-readme",
    "href": "readmes.html#writing-a-readme",
    "title": "Informative READMEs",
    "section": "Writing a README",
    "text": "Writing a README\nWe recommend that you edit your README to include (some of) the following components:\n\nAn informative, un-abbreviated title (beginning with one # to make it a header)\nA brief (likely bulleted) description of the major folders in the repository\nHow / in which folder to contribute new files to the repository\nContact information for primary contact for questions\nIf applicable, links to related repositories (e.g., other repositories created by your working group)\n\nThe most important thing is that you structure your README in a way that is intuitive to your team so that you feel capable to maintain it so that is remains useful and relevant as a landing page for your project.",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  },
  {
    "objectID": "readmes.html#other-resources-for-readmes",
    "href": "readmes.html#other-resources-for-readmes",
    "title": "Informative READMEs",
    "section": "Other Resources for READMEs",
    "text": "Other Resources for READMEs\nSam Csik created guidelines for READMEs for the Master of Environmental Data Science (MEDS) program at UCSB with a companion slide deck and both are extremely useful for the what/when/where of great READMEs.\nNavendu Pottekkat made a really cool “Awesome README” that includes several optional features to make a README awesome-r. In particular that README includes special badges showing the timing of the last commit and features embedded header and footer images. This type of aesthetic modification is not required but can be a fun way of making your README stand out!",
    "crumbs": [
      "Other Topics",
      "Informative READMEs"
    ]
  }
]